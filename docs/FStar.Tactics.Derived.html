<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>FStar.Tactics.Derived</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.ccs" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="module-fstar.tactics.derived">module FStar.Tactics.Derived</h1>
<p>fsdoc: no-summary-found</p>
<p>fsdoc: no-comment-found</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">let</span> ((_cur_goal ()):(Tac goal)):<span class="kw">match</span> goals () <span class="kw">with</span> []  -&gt; fail <span class="st">&quot;no more goals&quot;</span> | (Prims<span class="kw">.</span>Cons g _)  -&gt; g</a></code></pre></div>
<p>Return the current <em>goal</em>, not its type. (Ignores SMT goals)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">let</span> ((cur_env ()):(Tac env)):goal_env (_cur_goal ())</a></code></pre></div>
<p>[cur_env] returns the current goal’s environment</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">let</span> ((cur_goal ()):(Tac typ)):goal_type (_cur_goal ())</a></code></pre></div>
<p>[cur_goal] returns the current goal’s type</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">let</span> ((cur_witness ()):(Tac term)):goal_witness (_cur_goal ())</a></code></pre></div>
<p>[cur_witness] returns the current goal’s witness</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">let</span> ((with_policy pol (f:Unidentified product: [<span class="dt">unit</span>] (Tac &#39;a))):(Tac &#39;a)):<span class="kw">let</span>  old_pol = get_guard_policy () <span class="kw">in</span> set_guard_policy pol; <span class="kw">let</span>  r = f () <span class="kw">in</span> set_guard_policy old_pol; r</a></code></pre></div>
<p>Set the guard policy only locally, without affecting calling code</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">let</span> ((dismiss ()):(Tac <span class="dt">unit</span>)):<span class="kw">match</span> goals () <span class="kw">with</span> []  -&gt; fail <span class="st">&quot;dismiss: no more goals&quot;</span> | (Prims<span class="kw">.</span>Cons _ gs)  -&gt; set_goals gs</a></code></pre></div>
<p>Ignore the current goal. If left unproven, this will fail after the tactic finishes.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">let</span> ((flip ()):(Tac <span class="dt">unit</span>)):<span class="kw">let</span>  gs = goals () <span class="kw">in</span> <span class="kw">match</span> goals () <span class="kw">with</span> []|</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"> [_]  -&gt; fail <span class="st">&quot;flip: less than two goals&quot;</span> | (Prims<span class="kw">.</span>Cons g1 (Prims<span class="kw">.</span>Cons g2 gs))  -&gt; set_goals ((Prims<span class="kw">.</span>Cons g2 (Prims<span class="kw">.</span>Cons g1 gs)))</a></code></pre></div>
<p>Flip the order of the first two goals.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">let</span> ((qed ()):(Tac <span class="dt">unit</span>)):<span class="kw">match</span> goals () <span class="kw">with</span> []  -&gt; () | _  -&gt; fail <span class="st">&quot;qed: not done!&quot;</span></a></code></pre></div>
<p>Succeed if there are no more goals left, and fail otherwise.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">let</span> ((debug (m:<span class="dt">string</span>)):(Tac <span class="dt">unit</span>)):<span class="kw">if</span> debugging () <span class="kw">then</span> print m <span class="kw">else</span> ()</a></code></pre></div>
<p>[debug str] is similar to [print str], but will only print the message if the [–debug] option was given for the current module AND [–debug_level Tac] is on.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">let</span> ((smt ()):(Tac <span class="dt">unit</span>)):<span class="kw">match</span> (FStar<span class="kw">.</span>Pervasives<span class="kw">.</span>Native<span class="kw">.</span>Mktuple2 goals () smt_goals ()) <span class="kw">with</span> ([], _)  -&gt; fail <span class="st">&quot;smt: no active goals&quot;</span> | ((Prims<span class="kw">.</span>Cons g gs), gs&#39;)  -&gt; set_goals gs; set_smt_goals ((Prims<span class="kw">.</span>Cons g gs&#39;))</a></code></pre></div>
<p>[smt] will mark the current goal for being solved through the SMT. This does not immediately run the SMT: it just dumps the goal in the SMT bin. Note, if you dump a proof-relevant goal there, the engine will later raise an error.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">let</span> ((later ()):(Tac <span class="dt">unit</span>)):<span class="kw">match</span> goals () <span class="kw">with</span> (Prims<span class="kw">.</span>Cons g gs)  -&gt; set_goals (@(gs, (Prims<span class="kw">.</span>Cons g (Prims<span class="kw">.</span>Nil )))) | _  -&gt; fail <span class="st">&quot;later: no goals&quot;</span></a></code></pre></div>
<p>Push the current goal to the back.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">let</span> ((exact (t:term)):(Tac <span class="dt">unit</span>)):with_policy SMT ((<span class="kw">fun</span> () -&gt; t_exact <span class="kw">true</span> <span class="kw">false</span> t))</a></code></pre></div>
<p>[exact e] will solve a goal [Gamma |- w : t] if [e] has type exactly [t] in [Gamma]. Also, [e] needs to unift with [w], but this will almost always be the case since [w] is usually a uvar.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">let</span> ((apply (t:term)):(Tac <span class="dt">unit</span>)):t_apply <span class="kw">true</span> t</a></code></pre></div>
<p>[apply f] will attempt to produce a solution to the goal by an application of [f] to any amount of arguments (which need to be solved as further goals). The amount of arguments introduced is the least such that [f a_i] unifies with the goal’s type.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">let</span> ((apply_raw (t:term)):(Tac <span class="dt">unit</span>)):t_apply <span class="kw">false</span> t</a></code></pre></div>
<p>[apply_raw f] is like [apply], but will ask for all arguments regardless of whether they appear free in further goals. See the explanation in [t_apply].</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">let</span> ((exact_guard (t:term)):(Tac <span class="dt">unit</span>)):with_policy Goal ((<span class="kw">fun</span> () -&gt; t_exact <span class="kw">true</span> <span class="kw">false</span> t))</a></code></pre></div>
<p>Like [exact], but allows for the term [e] to have a type [t] only under some guard [g], adding the guard as a goal.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">let</span> ((divide (n:<span class="dt">int</span>) (l:Unidentified product: [<span class="dt">unit</span>] (Tac &#39;a)) (r:Unidentified product: [<span class="dt">unit</span>] (Tac &#39;b))):(Tac <span class="co">(*(&#39;a, &#39;b)))):if &lt;(n, 0) then fail &quot;divide: negative n&quot; else (); let  (gs, sgs) = (FStar.Pervasives.Native.Mktuple2 goals () smt_goals ()) in let  (gs1, gs2) = List.Tot.splitAt n gs in set_goals gs1; set_smt_goals (Prims.Nil ); let  x = l () in let  (gsl, sgsl) = (FStar.Pervasives.Native.Mktuple2 goals () smt_goals ()) in set_goals gs2; set_smt_goals (Prims.Nil ); let  y = r () in let  (gsr, sgsr) = (FStar.Pervasives.Native.Mktuple2 goals () smt_goals ()) in set_goals (@(gsl, gsr)); set_smt_goals (@(sgs, @(sgsl, sgsr))); ((FStar.Pervasives.Native.Mktuple2 x y))</span></a></code></pre></div>
<p>[divide n t1 t2] will split the current set of goals into the [n] first ones, and the rest. It then runs [t1] on the first set, and [t2] on the second, returning both results (and concatenating remaining goals).</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">let</span> ((focus (t:Unidentified product: [<span class="dt">unit</span>] (Tac &#39;a))):(Tac &#39;a)):<span class="kw">match</span> goals () <span class="kw">with</span> []  -&gt; fail <span class="st">&quot;focus: no goals&quot;</span> | (Prims<span class="kw">.</span>Cons g gs)  -&gt; <span class="kw">let</span>  sgs = smt_goals () <span class="kw">in</span> set_goals (Prims<span class="kw">.</span>Cons g (Prims<span class="kw">.</span>Nil )); set_smt_goals (Prims<span class="kw">.</span>Nil ); <span class="kw">let</span>  x = t () <span class="kw">in</span> set_goals (@(goals (), gs)); set_smt_goals (@(smt_goals (), sgs)); x</a></code></pre></div>
<p>[focus t] runs [t ()] on the current active goal, hiding all others and restoring them at the end.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">let</span> (dump1 (m:<span class="dt">string</span>)):focus ((<span class="kw">fun</span> () -&gt; dump m))</a></code></pre></div>
<p>Similar to [dump], but only dumping the current goal.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">let</span> ((<span class="dt">seq</span> (f:Unidentified product: [<span class="dt">unit</span>] (Tac <span class="dt">unit</span>)) (g:Unidentified product: [<span class="dt">unit</span>] (Tac <span class="dt">unit</span>))):(Tac <span class="dt">unit</span>)):focus ((<span class="kw">fun</span> () -&gt; f (); iterAll g))</a></code></pre></div>
<p>Runs tactic [t1] on the current goal, and then tactic [t2] on <em>each</em> subgoal produced by [t1]. Each invocation of [t2] runs on a proofstate with a single goal (they’re “focused”).</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">let</span> ((ngoals ()):(Tac <span class="dt">int</span>)):List<span class="kw">.</span>length (goals ())</a></code></pre></div>
<p>[ngoals ()] returns the number of goals</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">let</span> ((ngoals_smt ()):(Tac <span class="dt">int</span>)):List<span class="kw">.</span>length (smt_goals ())</a></code></pre></div>
<p>[ngoals_smt ()] returns the number of SMT goals</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">let</span> (join_all_smt_goals ()):<span class="kw">let</span>  (gs, sgs) = (FStar<span class="kw">.</span>Pervasives<span class="kw">.</span>Native<span class="kw">.</span>Mktuple2 goals () smt_goals ()) <span class="kw">in</span> set_smt_goals (Prims<span class="kw">.</span>Nil ); set_goals sgs; repeat&#39; join; <span class="kw">let</span>  sgs&#39; = goals () <span class="kw">in</span> set_goals gs; set_smt_goals sgs&#39;</a></code></pre></div>
<p>Join all of the SMT goals into one. This helps when all of them are expected to be similar, and therefore easier to prove at once by the SMT solver. TODO: would be nice to try to join them in a more meaningful way, as the order can matter.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">let</span> ((is_guard ()):(Tac <span class="dt">bool</span>)):Tactics<span class="kw">.</span>Types<span class="kw">.</span>is_guard (_cur_goal ())</a></code></pre></div>
<p>[is_guard] returns whether the current goal arised from a typechecking guard</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">let</span> ((rewrite&#39; (b:binder)):(Tac <span class="dt">unit</span>)):(&lt;|&gt;(&lt;|&gt;(((<span class="kw">fun</span> () -&gt; rewrite b)), ((<span class="kw">fun</span> () -&gt; binder_retype b; apply_lemma (_); rewrite b))), ((<span class="kw">fun</span> () -&gt; fail <span class="st">&quot;rewrite&#39; failed&quot;</span>)))) ()</a></code></pre></div>
<p>Like [rewrite], but works with equalities [v == e] and [e == v]</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">let</span> ((l_to_r (lems:list term)):(Tac <span class="dt">unit</span>)):<span class="kw">let</span>  ((first_or_trefl ()):(Tac <span class="dt">unit</span>)) = fold_left ((<span class="kw">fun</span> k l () -&gt; or_else ((<span class="kw">fun</span> () -&gt; apply_lemma l)) k)) trefl lems () <span class="kw">in</span> pointwise first_or_trefl</a></code></pre></div>
<p>Rewrites left-to-right, and bottom-up, given a set of lemmas stating equalities</p>
</body>
</html>
