<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>FStar.Tactics.PatternMatching</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.ccs" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="module-fstar.tactics.patternmatching">module FStar.Tactics.PatternMatching</h1>
<p>fsdoc: no-summary-found</p>
<p>fsdoc: no-comment-found</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">let</span> ((mustfail #a (t:Unidentified product: [<span class="dt">unit</span>] (Tac a)) (message:<span class="dt">string</span>)):(Tac <span class="dt">unit</span>)):<span class="kw">match</span> trytac t <span class="kw">with</span> (Some _)  -&gt; fail message | None  -&gt; ()</a></code></pre></div>
<p>Ensure that tactic <code>t</code> fails. *</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">let</span> ((exact_hyp (a:Type0) (h:binder)):(Tac <span class="dt">unit</span>)):<span class="kw">let</span>  hd = quote ((FStar<span class="kw">.</span>Squash<span class="kw">.</span>return_squash #a)) <span class="kw">in</span> exact (mk_app hd (Prims<span class="kw">.</span>Cons ((FStar<span class="kw">.</span>Pervasives<span class="kw">.</span>Native<span class="kw">.</span>Mktuple2 (pack ((Tv_Var (bv_of_binder h)))) Q_Explicit)) (Prims<span class="kw">.</span>Nil )))</a></code></pre></div>
<p>Use a hypothesis at type a to satisfy a goal at type squash a</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">let</span> ((exact_hyp&#39; (h:binder)):(Tac <span class="dt">unit</span>)):exact (pack ((Tv_Var (bv_of_binder h))))</a></code></pre></div>
<p>Use a hypothesis h (of type a) to satisfy a goal at type a</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">let</span> ((interp_pattern_aux (pat:pattern) (cur_bindings:bindings) (tm:term)):(Tac (match_res bindings))):admit (); <span class="kw">let</span>  (interp_any () cur_bindings tm) = <span class="kw">return</span> (Prims<span class="kw">.</span>Nil ) <span class="kw">in</span> <span class="kw">let</span>  (interp_var (v:varname) cur_bindings tm) = <span class="kw">match</span> List<span class="kw">.</span>Tot<span class="kw">.</span>assoc v cur_bindings <span class="kw">with</span> (Some tm&#39;)  -&gt; <span class="kw">if</span> term_eq tm tm&#39; <span class="kw">then</span> <span class="kw">return</span> cur_bindings <span class="kw">else</span> raise ((NonLinearMismatch ((FStar<span class="kw">.</span>Pervasives<span class="kw">.</span>Native<span class="kw">.</span>Mktuple3 v tm tm&#39;)))) | None  -&gt; <span class="kw">return</span> ((Prims<span class="kw">.</span>Cons ((FStar<span class="kw">.</span>Pervasives<span class="kw">.</span>Native<span class="kw">.</span>Mktuple2 v tm)) cur_bindings)) <span class="kw">in</span> <span class="kw">let</span>  (interp_qn (qn:qn) cur_bindings tm) = <span class="kw">match</span> inspect tm <span class="kw">with</span> (Tv_FVar fv)  -&gt; <span class="kw">if</span> =(fv_to_string fv, qn) <span class="kw">then</span> <span class="kw">return</span> cur_bindings <span class="kw">else</span> raise ((NameMismatch ((FStar<span class="kw">.</span>Pervasives<span class="kw">.</span>Native<span class="kw">.</span>Mktuple2 qn (fv_to_string fv))))) | _  -&gt; raise ((SimpleMismatch ((FStar<span class="kw">.</span>Pervasives<span class="kw">.</span>Native<span class="kw">.</span>Mktuple2 pat tm)))) <span class="kw">in</span> <span class="kw">let</span>  (interp_type cur_bindings tm) = <span class="kw">match</span> inspect tm <span class="kw">with</span> (Tv_Type ())  -&gt; <span class="kw">return</span> cur_bindings | _  -&gt; raise ((SimpleMismatch ((FStar<span class="kw">.</span>Pervasives<span class="kw">.</span>Native<span class="kw">.</span>Mktuple2 pat tm)))) <span class="kw">in</span> <span class="kw">let</span>  (interp_app (p_hd:(p:pattern:{<span class="st">&lt;&lt;(p, pat)})) (p_arg:(p:pattern:{&lt;&lt;(p, pat)})) cur_bindings tm) = match inspect tm with (Tv_App hd (arg, _))  -&gt; with_hd &lt;- interp_pattern_aux p_hd cur_bindings hd; with_arg &lt;- interp_pattern_aux p_arg with_hd arg; return with_arg | _  -&gt; raise ((SimpleMismatch ((FStar.Pervasives.Native.Mktuple2 pat tm)))) in match pat with PAny  -&gt; interp_any () cur_bindings tm | (PVar var)  -&gt; interp_var var cur_bindings tm | (PQn qn)  -&gt; interp_qn qn cur_bindings tm | PType  -&gt; interp_type cur_bindings tm | (PApp p_hd p_arg)  -&gt; interp_app p_hd p_arg cur_bindings tm | _  -&gt; fail &quot;?&quot;</span></a></code></pre></div>
<p>Match a pattern against a term. <code>cur_bindings</code> is a list of bindings collected while matching previous parts of the pattern. Returns a result in the exception monad. *</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">let</span> ((interp_pattern (pat:pattern)):Unidentified product: [term] (Tac (match_res bindings))):(<span class="kw">fun</span> (tm:term) -&gt; rev_bindings &lt;- interp_pattern_aux pat (Prims<span class="kw">.</span>Nil ) tm; <span class="kw">return</span> (List<span class="kw">.</span>Tot<span class="kw">.</span>rev rev_bindings))</a></code></pre></div>
<p>Match a pattern <code>pat</code> against a term. Returns a result in the exception monad. *</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">let</span> ((match_term pat (tm:term)):(Tac bindings)):<span class="kw">match</span> interp_pattern pat (norm_term (Prims<span class="kw">.</span>Nil ) tm) <span class="kw">with</span> (Success bb)  -&gt; bb | (Failure ex)  -&gt; Tactics<span class="kw">.</span>fail (string_of_match_exception ex)</a></code></pre></div>
<p>Match a term <code>tm</code> against a pattern <code>pat</code>. Raises an exception if the match fails. This is mostly useful for debugging: use <code>mgw</code> to capture matches. *</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">let</span> ((assoc_varname_fail (#b:Type) (key:varname) (ls:list <span class="co">(*(varname, b)))):(Tac b)):match List.Tot.assoc key ls with None  -&gt; fail (^(&quot;Not found: &quot;, key)) | (Some x)  -&gt; x</span></a></code></pre></div>
<p>Find a varname in an association list; fail if it can’t be found. *</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">let</span> ((solve_mp_for_single_hyp #a (name:varname) (pat:pattern) (hypotheses:list hypothesis) (body:Unidentified product: [matching_solution] (Tac a)) (part_sol:matching_solution)):(Tac a)):<span class="kw">match</span> hypotheses <span class="kw">with</span> []  -&gt; fail #a <span class="st">&quot;No matching hypothesis&quot;</span> | (Prims<span class="kw">.</span>Cons h hs)  -&gt; or_else ((<span class="kw">fun</span> () -&gt; <span class="kw">match</span> interp_pattern_aux pat part_sol.ms_vars (type_of_binder h) <span class="kw">with</span> (Failure ex)  -&gt; fail (^(<span class="st">&quot;Failed to match hyp: &quot;</span>, (string_of_match_exception ex))) | (Success bindings)  -&gt; <span class="kw">let</span>  ms_hyps = (Prims<span class="kw">.</span>Cons ((FStar<span class="kw">.</span>Pervasives<span class="kw">.</span>Native<span class="kw">.</span>Mktuple2 name h)) part_sol.ms_hyps) <span class="kw">in</span> body ({part_sol <span class="kw">with</span> ms_vars=bindings ms_hyps=ms_hyps}))) ((<span class="kw">fun</span> () -&gt; solve_mp_for_single_hyp name pat hs body part_sol))</a></code></pre></div>
<p>Scan <code>hypotheses</code> for a match for <code>pat</code> that lets <code>body</code> succeed.</p>
<p><code>name</code> is used to refer to the hypothesis matched in the final solution. <code>part_sol</code> includes bindings gathered while matching previous solutions. *</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">let</span> ((solve_mp_for_hyps #a (mp_hyps:list <span class="co">(*(varname, pattern))) (hypotheses:list hypothesis) (body:Unidentified product: [matching_solution] (Tac a)) (partial_solution:matching_solution)):(Tac a)):match mp_hyps with []  -&gt; body partial_solution | (Prims.Cons (name, pat) pats)  -&gt; solve_mp_for_single_hyp name pat hypotheses (solve_mp_for_hyps pats hypotheses body) partial_solution</span></a></code></pre></div>
<p>Scan <code>hypotheses</code> for matches for <code>mp_hyps</code> that lets <code>body</code> succeed. *</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">let</span> ((solve_mp #a (problem:matching_problem) (hypotheses:binders) (goal:term) (body:Unidentified product: [matching_solution] (Tac a))):(Tac a)):<span class="kw">let</span>  goal_ps = <span class="kw">match</span> problem.mp_goal <span class="kw">with</span> None  -&gt; {ms_vars=(Prims<span class="kw">.</span>Nil ) ms_hyps=(Prims<span class="kw">.</span>Nil )} | (Some pat)  -&gt; <span class="kw">match</span> interp_pattern pat goal <span class="kw">with</span> (Failure ex)  -&gt; fail (^(<span class="st">&quot;Failed to match goal: &quot;</span>, (string_of_match_exception ex))) | (Success bindings)  -&gt; {ms_vars=bindings ms_hyps=(Prims<span class="kw">.</span>Nil )} <span class="kw">in</span> solve_mp_for_hyps #a problem.mp_hyps hypotheses body goal_ps</a></code></pre></div>
<p>Solve a matching problem.</p>
<p>The solution returned is constructed to ensure that the continuation <code>body</code> succeeds: this implements the usual backtracking-match semantics. *</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">let</span> ((pattern_of_term_ex tm):(Tac (match_res pattern))):<span class="kw">match</span> inspect tm <span class="kw">with</span> (Tv_Var bv)  -&gt; <span class="kw">return</span> ((PVar (name_of_bv bv))) | (Tv_FVar fv)  -&gt; <span class="kw">let</span>  qn = fv_to_string fv <span class="kw">in</span> <span class="kw">return</span> (<span class="kw">if</span> =(qn, any_qn) <span class="kw">then</span> PAny <span class="kw">else</span> (PQn qn)) | (Tv_Type ())  -&gt; <span class="kw">return</span> PType | (Tv_App f (x, _))  -&gt; <span class="kw">let</span>  is_any = <span class="kw">match</span> inspect f <span class="kw">with</span> (Tv_FVar fv)  -&gt; =(fv_to_string fv, any_qn) | _  -&gt; <span class="kw">false</span> <span class="kw">in</span> <span class="kw">if</span> is_any <span class="kw">then</span> <span class="kw">return</span> PAny <span class="kw">else</span> (fpat &lt;- pattern_of_term_ex f; xpat &lt;- pattern_of_term_ex x; <span class="kw">return</span> ((PApp fpat xpat))) | _  -&gt; raise ((UnsupportedTermInPattern tm))</a></code></pre></div>
<p>Compile a term <code>tm</code> into a pattern. *</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">let</span> ((beta_reduce (tm:term)):(Tac term)):norm_term (Prims<span class="kw">.</span>Nil ) tm</a></code></pre></div>
<p>β-reduce a term <code>tm</code>. This is useful to remove needles function applications introduced by F<em>, like <code>(fun a b c -&gt; a) 1 2 3</code>. </em></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">let</span> ((pattern_of_term tm):(Tac pattern)):<span class="kw">match</span> pattern_of_term_ex tm <span class="kw">with</span> (Success bb)  -&gt; bb | (Failure ex)  -&gt; Tactics<span class="kw">.</span>fail (string_of_match_exception ex)</a></code></pre></div>
<p>Compile a term <code>tm</code> into a pattern. *</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">let</span> ((binders_and_body_of_abs tm):(Tac <span class="co">(*(binders, term)))):match inspect tm with (Tv_Abs binder tm)  -&gt; let  (binders, body) = binders_and_body_of_abs tm in (FStar.Pervasives.Native.Mktuple2 (Prims.Cons binder binders) body) | _  -&gt; (FStar.Pervasives.Native.Mktuple2 (Prims.Nil ) tm)</span></a></code></pre></div>
<p>Split an abstraction <code>tm</code> into a list of binders and a body. *</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">let</span> ((matching_problem_of_abs (tm:term)):(Tac <span class="co">(*(matching_problem, abspat_continuation)))):let  (binders, body) = binders_and_body_of_abs (cleanup_abspat tm) in debug (^(&quot;Got binders: &quot;, (String.concat &quot;, &quot; (map ((fun b -&gt; (name_of_binder b : (Tac string)))) binders)))); let  classified_binders = map ((fun binder -&gt; let  bv_name = name_of_binder binder in debug (^(&quot;Got binder: &quot;, ^(bv_name, ^(&quot;; type is &quot;, term_to_string (type_of_binder binder))))); let  (binder_kind, typ) = classify_abspat_binder binder in ((FStar.Pervasives.Native.Mktuple4 binder bv_name binder_kind typ)))) binders in let  problem = fold_left ((fun problem (binder, bv_name, binder_kind, typ) -&gt; debug (^(&quot;Compiling binder &quot;, ^(name_of_binder binder, ^(&quot;, classified as &quot;, ^(string_of_abspat_binder_kind binder_kind, ^(&quot;, with type &quot;, term_to_string typ)))))); match binder_kind with (ABKVar _)  -&gt; {problem with mp_vars=(Prims.Cons bv_name problem.mp_vars)} | ABKHyp  -&gt; {problem with mp_hyps=(Prims.Cons ((FStar.Pervasives.Native.Mktuple2 bv_name (pattern_of_term typ))) problem.mp_hyps)} | ABKGoal  -&gt; {problem with mp_goal=(Some (pattern_of_term typ))})) ({mp_vars=(Prims.Nil ) mp_hyps=(Prims.Nil ) mp_goal=None}) classified_binders in let  continuation = let  ((abspat_argspec_of_binder xx):(Tac abspat_argspec)) = match xx with (binder, xx, binder_kind, yy)  -&gt; {asa_name=binder asa_kind=binder_kind} in ((FStar.Pervasives.Native.Mktuple2 map abspat_argspec_of_binder classified_binders tm)) in let  mp = {mp_vars=List.rev #varname problem.mp_vars mp_hyps=List.rev #(*(varname, pattern)) problem.mp_hyps mp_goal=problem.mp_goal} in debug (^(&quot;Got matching problem: &quot;, (string_of_matching_problem mp))); (FStar.Pervasives.Native.Mktuple2 mp continuation)</span></a></code></pre></div>
<p>Parse a notation into a matching problem and a continuation.</p>
<p>Pattern-matching notations are of the form <code>(fun binders… -&gt; continuation)</code>, where <code>binders</code> are of one of the forms <code>var …</code>, <code>hyp …</code>, or <code>goal …</code>. <code>var</code> binders are typed holes to be used in other binders; <code>hyp</code> binders indicate a pattern to be matched against hypotheses; and <code>goal</code> binders match the goal.</p>
<p>A reduction phase is run to ensure that the pattern looks reasonable; it is needed because F* tends to infer arguments in β-expanded form.</p>
<p>The continuation returned can’t directly be applied to a pattern-matching solution; see <code>interp_abspat_continuation</code> below for that. *</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">let</span> ((arg_type_of_binder_kind binder_kind):(Tac term)):<span class="kw">match</span> binder_kind <span class="kw">with</span> (ABKVar typ)  -&gt; typ | ABKHyp  -&gt; (`(binder)) | ABKGoal  -&gt; (`(<span class="dt">unit</span>))</a></code></pre></div>
<p>Get the (quoted) type expected by a specific kind of abspat binder. *</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">let</span> (locate_fn_of_binder_kind binder_kind):<span class="kw">match</span> binder_kind <span class="kw">with</span> (ABKVar _)  -&gt; (`(ms_locate_var)) | ABKHyp  -&gt; (`(ms_locate_hyp)) | ABKGoal  -&gt; (`(ms_locate_unit))</a></code></pre></div>
<p>Retrieve the function used to locate a value for a given abspat binder. *</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">let</span> ((abspat_arg_of_abspat_argspec solution_term (argspec:abspat_argspec)):(Tac term)):<span class="kw">let</span>  loc_fn = locate_fn_of_binder_kind argspec.asa_kind <span class="kw">in</span> <span class="kw">let</span>  name_tm = pack ((Tv_Const ((C_String (name_of_binder argspec.asa_name))))) <span class="kw">in</span> <span class="kw">let</span>  locate_args = (Prims<span class="kw">.</span>Cons ((FStar<span class="kw">.</span>Pervasives<span class="kw">.</span>Native<span class="kw">.</span>Mktuple2 arg_type_of_binder_kind argspec.asa_kind Q_Explicit)) (Prims<span class="kw">.</span>Cons ((FStar<span class="kw">.</span>Pervasives<span class="kw">.</span>Native<span class="kw">.</span>Mktuple2 solution_term Q_Explicit)) (Prims<span class="kw">.</span>Cons ((FStar<span class="kw">.</span>Pervasives<span class="kw">.</span>Native<span class="kw">.</span>Mktuple2 name_tm Q_Explicit)) (Prims<span class="kw">.</span>Nil )))) <span class="kw">in</span> mk_app loc_fn locate_args</a></code></pre></div>
<p>Construct a term fetching the value of an abspat argument from a quoted matching solution <code>solution_term</code>. *</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">let</span> ((specialize_abspat_continuation&#39; (continuation:abspat_continuation) (solution_term:term)):(Tac term)):<span class="kw">let</span>  (mk_arg argspec) = ((FStar<span class="kw">.</span>Pervasives<span class="kw">.</span>Native<span class="kw">.</span>Mktuple2 abspat_arg_of_abspat_argspec solution_term argspec Q_Explicit)) <span class="kw">in</span> <span class="kw">let</span>  (argspecs, body) = continuation <span class="kw">in</span> mk_app body (map mk_arg argspecs)</a></code></pre></div>
<p>Specialize a continuation of type <code>abspat_continuation</code>. This constructs a fully applied version of <code>continuation</code>, but it requires a quoted solution to be passed in. *</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">let</span> ((specialize_abspat_continuation (continuation:abspat_continuation)):(Tac term)):<span class="kw">let</span>  solution_binder = fresh_binder ((`(matching_solution))) <span class="kw">in</span> <span class="kw">let</span>  solution_term = pack ((Tv_Var (bv_of_binder solution_binder))) <span class="kw">in</span> <span class="kw">let</span>  applied = specialize_abspat_continuation&#39; continuation solution_term <span class="kw">in</span> <span class="kw">let</span>  thunked = pack ((Tv_Abs solution_binder applied)) <span class="kw">in</span> debug (^(<span class="st">&quot;Specialized into &quot;</span>, (term_to_string thunked))); <span class="kw">let</span>  normalized = beta_reduce thunked <span class="kw">in</span> debug (^(<span class="st">&quot;… which reduces to &quot;</span>, (term_to_string normalized))); thunked</a></code></pre></div>
<p>Specialize a continuation of type <code>abspat_continuation</code>. This yields a quoted function taking a matching solution and running its body with appropriate bindings. *</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">let</span> ((interp_abspat_continuation (a:Type0) (continuation:abspat_continuation)):(Tac (Unidentified product: [matching_solution] (Tac a)))):<span class="kw">let</span>  applied = specialize_abspat_continuation continuation <span class="kw">in</span> unquote #(Unidentified product: [matching_solution] (Tac a)) applied</a></code></pre></div>
<p>Interpret a continuation of type <code>abspat_continuation</code>. This yields a function taking a matching solution and running the body of the continuation with appropriate bindings. *</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">let</span> ((interp_abspat #a (abspat:a)):(Tac <span class="co">(*(matching_problem, abspat_continuation)))):matching_problem_of_abs (quote (abspat))</span></a></code></pre></div>
<p>Construct a matching problem from an abspat. *</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">let</span> ((match_abspat #b #a (abspat:a) (k:Unidentified product: [abspat_continuation] (Tac (Unidentified product: [matching_solution] (Tac b))))):(Tac b)):<span class="kw">let</span>  goal = cur_goal () <span class="kw">in</span> <span class="kw">let</span>  hypotheses = binders_of_env (cur_env ()) <span class="kw">in</span> <span class="kw">let</span>  (problem, continuation) = interp_abspat abspat <span class="kw">in</span> admit (); solve_mp #matching_solution problem hypotheses goal (k continuation)</a></code></pre></div>
<p>Construct an solve a matching problem. This higher-order function isn’t very usable on its own — it’s mostly a convenience function to avoid duplicating the problem-parsing code. *</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">let</span> ((inspect_abspat_problem #a (abspat:a)):(Tac matching_problem)):fst (interp_abspat #a abspat)</a></code></pre></div>
<p>Inspect the matching problem produced by parsing an abspat. *</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb25-1" title="1"><span class="kw">let</span> ((inspect_abspat_solution #a (abspat:a)):(Tac matching_solution)):match_abspat abspat ((<span class="kw">fun</span> _ -&gt; (((<span class="kw">fun</span> solution -&gt; solution)) : (Tac _))))</a></code></pre></div>
<p>Inspect the matching solution produced by parsing and solving an abspat. *</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">let</span> ((gpm #b #a (abspat:a) ()):(Tac b)):<span class="kw">let</span>  (continuation, solution) = match_abspat abspat tpair <span class="kw">in</span> interp_abspat_continuation b continuation solution</a></code></pre></div>
<p>Solve a greedy pattern-matching problem and run its continuation. This if for pattern-matching problems in the <code>Tac</code> effect. *</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">let</span> ((pm #b #a (abspat:a)):(Tac b)):match_abspat abspat (interp_abspat_continuation b)</a></code></pre></div>
<p>Solve a greedy pattern-matching problem and run its continuation. This if for pattern-matching problems in the <code>Tac</code> effect. *</p>
</body>
</html>
