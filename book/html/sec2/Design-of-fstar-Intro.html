

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Elements of F* &mdash; Proof-Oriented Programming in F*  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Foundations of Programming Languages" href="../PL-pl-foundations.html" />
    <link rel="prev" title="Getting off the ground" href="../part1/part1_ch1.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> Proof-Oriented Programming in F*
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../part1/part1.html">Programming and Proving with Total Functions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Elements of F*</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#core-language">Core Language</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#basic-syntactic-structure">Basic syntactic structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#classes-of-identifiers">Classes of Identifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#comments">Comments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#primitive-constants">Primitive constants</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#false">False</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unit">Unit</a></li>
<li class="toctree-l4"><a class="reference internal" href="#booleans">Booleans</a></li>
<li class="toctree-l4"><a class="reference internal" href="#integers">Integers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#user-defined-operators-and-infix-notation">User-defined operators and infix notation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#boolean-refinement-types">Boolean refinement types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#some-simple-refinement-types">Some simple refinement types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#refinement-subtyping">Refinement subtyping</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#function-types-or-arrows">Function types or arrows</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#total-dependent-functions">Total dependent functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#type-the-type-of-types">Type: The type of types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#parametric-polymorphism-or-generics">Parametric polymorphism or generics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#type-inference-basics">Type inference: Basics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#implicit-arguments">Implicit arguments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#universes">Universes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#syntax-of-binders">Syntax of binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="#decidable-equality-and-eqtype">Decidable equality and <cite>eqtype</cite></a></li>
<li class="toctree-l3"><a class="reference internal" href="#let-bindings">Let bindings</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inductive-type-definitions">Inductive type definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#discriminators">Discriminators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#projectors">Projectors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#equality">Equality</a></li>
<li class="toctree-l4"><a class="reference internal" href="#positivity">Positivity</a></li>
<li class="toctree-l4"><a class="reference internal" href="#universe-constraints">Universe constraints</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pattern-matching">Pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="#recursive-definitions-and-termination">Recursive definitions and termination</a></li>
<li class="toctree-l3"><a class="reference internal" href="#refinement-types">Refinement Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#proof-irrelevance-squash-types-and-classical-logic">Proof irrelevance, squash types and classical logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="#misc">Misc</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#evaluation-strategy">Evaluation strategy</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#effects">Effects</a></li>
<li class="toctree-l2"><a class="reference internal" href="#modules-and-interfaces">Modules and Interfaces</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#a-mental-model-of-the-f-typechecker">A Mental Model of the F* Typechecker</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../PL-pl-foundations.html">Foundations of Programming Languages</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Proof-Oriented Programming in F*</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Elements of F*</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">

           <div itemprop="articleBody">
            
  <div class="section" id="elements-of-f">
<span id="design-of-fstar-intro"></span><h1>Elements of F*<a class="headerlink" href="#elements-of-f" title="Permalink to this headline">¶</a></h1>
<p>The short tutorial should have provided you
with a basic feel for F*, in particular for how to use F* and its SMT
solving backend for programming and proving simple functional
programs.</p>
<p>In this section, we step back and provide a more comprehensive
description of F*, starting from short summary of its design goals and
main technical features. Not all of these concepts may be familiar to
you at first, but by the end of this section, you should have gained a
working knowledge of the core design of F* as well as pointers to
further resources.</p>
<div class="section" id="core-language">
<h2>Core Language<a class="headerlink" href="#core-language" title="Permalink to this headline">¶</a></h2>
<p>The syntax of F*’s core language is summarized by the simplified
grammar of terms, representing the core abstract syntax of terms used
by the F* typechecker. Note, this is not the full concrete syntax of
F* terms, which includes many additional features, including
parentheses for enforcing precedence, implicit arguments, n-ary
functions, various forms of syntactic sugar for common constructs like
tuples and sequencing, etc. However, the essence of F*’s core language
is distilled below. Understand how all these constructs fit together
and you should be able to see how the core of F* is simultaneously a
functional programming language and a logic. The goal of this section
is to explain all these constructs in detail, down to specifics of the
various syntactic conventions used in F*.</p>
<p>Core abstract syntax of F* terms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Constants c ::= p                                       primitive constant
              | D                                       user-defined data constructors
              | T                                       user-defined inductive type constructors

Terms  e, t ::= x                                       variables

              | c                                       constants and constructors


              | fun (x:t) -&gt; t&#39;                         functions

              | t t&#39;                                    applications

              | match t with [b1 ... bn]                pattern matching with zero or more cases

              | let x = t in t&#39;                         let bindings

              | let rec f1 (x:t1) : t1&#39; = e1 ...
                and ... fn (x:tn) : tn&#39; = en            mutually recursive function definitions

              | x:t -&gt; t                                function types (arrows)

              | x:t { t&#39; }                              refinement types

              | Type u#U                                Type of types

              | x u#U1 ... u#Un                         Variable applied to one or more universes

Case     X  ::= `|` P -&gt; t                              Pattern-matching branch

Pattern  P  ::= x                                       Variable
              | c                                       Constant
              | D [P1...Pn]                             Constructor applied to zero or more patterns

Universe U  ::= x                                       Universe variable
              | 0                                       Universe 0
              | U + 1                                   Successor universe
              | max U U                                 Maximum of universes
</pre></div>
</div>
<div class="section" id="basic-syntactic-structure">
<h3>Basic syntactic structure<a class="headerlink" href="#basic-syntactic-structure" title="Permalink to this headline">¶</a></h3>
<p>An F* program is a collection of <a class="reference internal" href="#modules"><span class="std std-ref">modules</span></a>, with each
module represented by a single file with the filename extension
<code class="docutils literal notranslate"><span class="pre">.fst</span></code>. Later, we’ll see that a module’s interface is in a separate
file.</p>
<p>A module begins with the module’s name and contains a sequence of
top-level signatures and definitions.</p>
<ul class="simple">
<li><p>Signatures ascribe a type to a definition, e.g., <code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">f</span> <span class="pre">:</span> <span class="pre">t</span></code>.</p></li>
</ul>
<p>Definitions come in several flavors: the two main forms we’ll focus on
in this section are</p>
<ul class="simple">
<li><p>possibly recursive definitions (let bindings, <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">[rec]</span> <span class="pre">f</span> <span class="pre">=</span> <span class="pre">e</span></code>)</p></li>
<li><p>and, inductive type definitions (datatypes, <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">|</span> <span class="pre">D1</span> <span class="pre">:</span> <span class="pre">t1</span> <span class="pre">|</span> <span class="pre">...</span> <span class="pre">|</span> <span class="pre">Dn</span> <span class="pre">:</span> <span class="pre">tn</span></code>)</p></li>
</ul>
<p>In later sections, we’ll see two other kinds of definition:
user-defined indexed effects and sub-effects.</p>
<div class="section" id="classes-of-identifiers">
<h4>Classes of Identifiers<a class="headerlink" href="#classes-of-identifiers" title="Permalink to this headline">¶</a></h4>
<p>TODO:</p>
</div>
<div class="section" id="comments">
<h4>Comments<a class="headerlink" href="#comments" title="Permalink to this headline">¶</a></h4>
<p>Block comments are delimited by <code class="docutils literal notranslate"><span class="pre">(*</span></code> and <code class="docutils literal notranslate"><span class="pre">*)</span></code>. Line comments begin
with <code class="docutils literal notranslate"><span class="pre">//</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">*</span> <span class="n">this</span> <span class="ow">is</span> <span class="n">a</span>
   <span class="n">block</span> <span class="n">comment</span> <span class="o">*</span><span class="p">)</span>


<span class="o">//</span><span class="n">This</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">line</span> <span class="n">comment</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="primitive-constants">
<h3>Primitive constants<a class="headerlink" href="#primitive-constants" title="Permalink to this headline">¶</a></h3>
<p>Every F* program is checked in the context of some ambient primitive
definitions taken from the core F* module <a class="reference internal" href="../index.html#corelib-prims"><span class="std std-ref">Prims</span></a>.</p>
<div class="section" id="false">
<h4>False<a class="headerlink" href="#false" title="Permalink to this headline">¶</a></h4>
<p>The type <code class="docutils literal notranslate"><span class="pre">False</span></code> has no elements. It represents a logical
falsehood in F*—</p>
</div>
<div class="section" id="unit">
<h4>Unit<a class="headerlink" href="#unit" title="Permalink to this headline">¶</a></h4>
<p>The type <code class="docutils literal notranslate"><span class="pre">unit</span></code> has a single element denoted <code class="docutils literal notranslate"><span class="pre">()</span></code>.</p>
</div>
<div class="section" id="booleans">
<h4>Booleans<a class="headerlink" href="#booleans" title="Permalink to this headline">¶</a></h4>
<p>The primitive type <code class="docutils literal notranslate"><span class="pre">bool</span></code> has two elements, <code class="docutils literal notranslate"><span class="pre">true</span></code> and
<code class="docutils literal notranslate"><span class="pre">false</span></code>. <code class="docutils literal notranslate"><span class="pre">Prims</span></code> also provides the following primitive boolean
operators</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>: Boolean conjunction (infix)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">||</span></code>: Boolean disjunction (infix)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">not</span></code>: Boolean negation (prefix)</p></li>
</ul>
<p>TODO: Precedence</p>
</div>
<div class="section" id="integers">
<h4>Integers<a class="headerlink" href="#integers" title="Permalink to this headline">¶</a></h4>
<p>The type <code class="docutils literal notranslate"><span class="pre">int</span></code> represents unbounded, primitive mathematical
integers. Its elements are formed from the literals <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">...</span></code>,
and the following primitive operators:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-</span></code>: Unary negation (prefix)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-</span></code>: Subtraction (infix)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">+</span></code>: Addition (infix)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/</span></code>: Euclidean division (infix)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%</span></code>: Euclidean modulus (infix)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">op_Multiply</span></code>: Unfortunately, the traditional multiplication symbol
<code class="docutils literal notranslate"><span class="pre">*</span></code> is reserved by default for the <a class="reference internal" href="#tuples"><span class="std std-ref">tuple</span></a> type
constructor. Use the module <code class="docutils literal notranslate"><span class="pre">FStar.Mul</span></code> to treat <code class="docutils literal notranslate"><span class="pre">*</span></code> as integer
multiplication—see <a class="reference internal" href="#tuples"><span class="std std-ref">this note</span></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;</span></code> : Less than (infix)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>: Less than or equal (infix)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&gt;</span></code> : Greater than (infix)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>: Greater than or equal (infix)</p></li>
</ul>
<p>TODO: Precedence</p>
</div>
</div>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<p>F* provides several forms of syntactic sugar to define functions. The
syntax is largely inherited from OCaml, and this
<a class="reference external" href="https://ocaml.org/learn/tutorials/basics.html#Defining-a-function">OCaml tutorial</a>
provides more details for those unfamiliar with the language.</p>
<p>The following are synonyms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">incr</span> <span class="o">=</span> <span class="n">fun</span> <span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">let</span> <span class="n">incr</span> <span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>You can also let F* infer the type of the parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">incr</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Functions can take several arguments and the result type of a function
can also be annotated, if desired:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">incr</span> <span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">let</span> <span class="n">more_than_twice</span> <span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>It’s considered good practice to annotate all the parameters and
result type of a top-level definition.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The type of any term in F* can be annotated using a <em>type
ascription</em>, <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">&lt;:</span> <span class="pre">t</span></code>. This form instructs F* to check that the
term <code class="docutils literal notranslate"><span class="pre">e</span></code> has the type <code class="docutils literal notranslate"><span class="pre">t</span></code>. For example, we could have written:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">incr</span> <span class="o">=</span> <span class="n">fun</span> <span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
<p>We’ll cover more about type ascriptions in this later
<a class="reference internal" href="#ascriptions"><span class="std std-ref">section</span></a>.</p>
</div>
<div class="section" id="user-defined-operators-and-infix-notation">
<h4>User-defined operators and infix notation<a class="headerlink" href="#user-defined-operators-and-infix-notation" title="Permalink to this headline">¶</a></h4>
<p>Most commonly, to call, or “apply”, a function, just place the
arguments to the right of the function. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>incr 0 // calls ``incr`` with the argument 0
more_than_twice 17 8 //calls ``more_than_twice`` with ``17`` and ``8``
</pre></div>
</div>
<p>You can also immediately apply an unnamed function, or lambda term:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">fun</span> <span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">0</span>
</pre></div>
</div>
<p>However, functions with two arguments can be applied in infix
notation, enclosing the function’s name in “backticks”. For example,
one could write, which can sometimes make code more readable.</p>
<blockquote>
<div><p>17 `more_than_twice` 8</p>
</div></blockquote>
<p>Functions can also be given names using special operator symbols,
e.g., one could write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="p">(</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="n">more_than_twice</span>
</pre></div>
</div>
<p>And then call the function using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">17</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span>
</pre></div>
</div>
<p>This <a class="reference external" href="https://github.com/FStarLang/FStar/wiki/Parsing-and-operator-precedence">wiki page</a>
provides more details on defining functions with operator symbols.</p>
</div>
</div>
<div class="section" id="boolean-refinement-types">
<h3>Boolean refinement types<a class="headerlink" href="#boolean-refinement-types" title="Permalink to this headline">¶</a></h3>
<p>Types are a way to describe collections of terms. For instance, the
type <code class="docutils literal notranslate"><span class="pre">int</span></code> describes terms which compute integer results, i.e., when
an <code class="docutils literal notranslate"><span class="pre">int</span></code>-typed term is reduced fully it produces a value in the set
<code class="docutils literal notranslate"><span class="pre">{...,</span> <span class="pre">-2,</span> <span class="pre">-1,</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">...}</span></code>. Similarly, the type <code class="docutils literal notranslate"><span class="pre">bool</span></code> is the type
of terms that compute or evaluate to one of the values in the set
<code class="docutils literal notranslate"><span class="pre">{true,false}</span></code>.</p>
<p>One (naive but useful) mental model is to think of a type as
describing a set of values. With that in mind, and unlike in other
mainstream programming languages, one can contemplate defining types
for arbitrary sets of values. We will see a great many ways to define
such types, starting with boolean refinement types.</p>
<div class="section" id="some-simple-refinement-types">
<h4>Some simple refinement types<a class="headerlink" href="#some-simple-refinement-types" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="../index.html#corelib-prims"><span class="std std-ref">Prims</span></a> defines the type of natural numbers as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">nat</span> <span class="o">=</span> <span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">}</span>
</pre></div>
</div>
<p>This is an instance of a boolean refinement type, whose general form
is <code class="docutils literal notranslate"><span class="pre">x:t</span> <span class="pre">{</span> <span class="pre">e</span> <span class="pre">}</span></code> where <code class="docutils literal notranslate"><span class="pre">t</span></code> is a type, and <code class="docutils literal notranslate"><span class="pre">e</span></code> is a <code class="docutils literal notranslate"><span class="pre">bool</span></code>-typed term
that may refer to the <code class="docutils literal notranslate"><span class="pre">t</span></code>-typed bound variable <code class="docutils literal notranslate"><span class="pre">x</span></code>. The term <code class="docutils literal notranslate"><span class="pre">e</span></code>
<em>refines</em> the type <code class="docutils literal notranslate"><span class="pre">t</span></code>, in the sense that the set <code class="docutils literal notranslate"><span class="pre">S</span></code> denoted by <code class="docutils literal notranslate"><span class="pre">t</span></code>
is restricted to those elements <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">$\in$</span> <span class="pre">S</span></code> for which <code class="docutils literal notranslate"><span class="pre">e</span></code> evaluates to
<code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<p>That is the type <code class="docutils literal notranslate"><span class="pre">nat</span></code> describes the set of terms that evaluate to an
element of the set <code class="docutils literal notranslate"><span class="pre">{0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">...}</span></code>.</p>
<p>But, there’s nothing particularly special about <code class="docutils literal notranslate"><span class="pre">nat</span></code>. You can define
arbitrary refinements of your choosing, e.g.,:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let empty = x:int { false } //one type for the empty set
let zero = x:int{ x = 0 } //the type containing one element `0`
let pos = x:int { x &gt; 0 } //the positive numbers
let neg = x:int { x &lt; 0 } //the negative numbers
let even = x:int { x % 2 = 0 } //the even numbers
let odd = x:int { x % 2 = 1 } //the odd numbers
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Refinement types in F* trace their lineage to <a class="reference external" href="https://www.microsoft.com/en-us/research/project/f7-refinement-types-for-f/">F7</a>,
a language developed at Microsoft Research c. 2007 – 2011. <a class="reference external" href="https://ucsd-progsys.github.io/liquidhaskell-blog/">Liquid
Haskell</a> is
another language with refinement types. Those languages provide
additional background and resources for learning about refinement
types.</p>
<p>Refinement types, in conjunction with dependent function types,
are, in principle, sufficient to encode many kinds of logics for
program correctness. However, refinement types are just one among
several tools in F* for program specification and proof.</p>
</div>
</div>
<div class="section" id="refinement-subtyping">
<h4>Refinement subtyping<a class="headerlink" href="#refinement-subtyping" title="Permalink to this headline">¶</a></h4>
<p>We have seen so far how to define a new refinement type, like <code class="docutils literal notranslate"><span class="pre">nat</span></code> or
<code class="docutils literal notranslate"><span class="pre">even</span></code>. However, to make use of refinement types we need rules that
allow us to:</p>
<ol class="arabic simple">
<li><p>check that a program term has a given refinement type, e.g., to
check that <code class="docutils literal notranslate"><span class="pre">0</span></code> has type <code class="docutils literal notranslate"><span class="pre">nat</span></code>. This is sometimes called
<em>introducing</em> a refinement type.</p></li>
<li><p>make use of a term that has a refinement type, e.g., given <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span>
<span class="pre">even</span></code> we would like to be write <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code>, treating <code class="docutils literal notranslate"><span class="pre">x</span></code> as an <code class="docutils literal notranslate"><span class="pre">int</span></code>
to add <code class="docutils literal notranslate"><span class="pre">1</span></code> to it. This is sometimes called <em>eliminating</em> a
refinement type.</p></li>
</ol>
<p>The technical mechanism in F* that supports both these features is
called <em>refinement subtyping</em>.</p>
<p>If you’re used to a language like Java, C# or some other
object-oriented language, you’re familiar with the idea of
subtyping. A type <code class="docutils literal notranslate"><span class="pre">t</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">s</span></code> whenever a program term of
type <code class="docutils literal notranslate"><span class="pre">t</span></code> can be safely treated as an <code class="docutils literal notranslate"><span class="pre">s</span></code>. For example, in Java, all
object types are subtypes of the type <code class="docutils literal notranslate"><span class="pre">Object</span></code>, the base class of all
objects.</p>
<p>For boolean refinement types, the subtyping rules are as follows:</p>
<ul class="simple">
<li><p>The type <code class="docutils literal notranslate"><span class="pre">x:t</span> <span class="pre">{</span> <span class="pre">p</span> <span class="pre">}</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">t</span></code>. That is, given <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">:</span>
<span class="pre">(x:t{p})</span></code>, it is always safe to <em>eliminate</em> the refinement and
consider <code class="docutils literal notranslate"><span class="pre">e</span></code> to also have type <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p></li>
<li><p>For a term <code class="docutils literal notranslate"><span class="pre">e</span></code> of type <code class="docutils literal notranslate"><span class="pre">t</span></code> (i.e., <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">:</span> <span class="pre">t</span></code>), <code class="docutils literal notranslate"><span class="pre">t</span></code> is a subtype of the
boolean refinement type <code class="docutils literal notranslate"><span class="pre">x:t</span> <span class="pre">{</span> <span class="pre">p</span> <span class="pre">}</span></code> whenever <code class="docutils literal notranslate"><span class="pre">p[e</span> <span class="pre">/</span> <span class="pre">x]</span></code> is provably
equal to <code class="docutils literal notranslate"><span class="pre">true</span></code>. In other words, to <em>introduce</em> <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">:</span> <span class="pre">t</span></code> at the
boolean refinement type <code class="docutils literal notranslate"><span class="pre">x:t{</span> <span class="pre">p</span> <span class="pre">}</span></code>, it suffices to prove that the
term <code class="docutils literal notranslate"><span class="pre">p</span></code> with <code class="docutils literal notranslate"><span class="pre">e</span></code> substituted for bound variable <code class="docutils literal notranslate"><span class="pre">x</span></code>, evaluates to
<code class="docutils literal notranslate"><span class="pre">true</span></code>.</p></li>
</ul>
<p>The the elimination rule for refinement types (i.e., the first part
above) is simple—with our intuition of types as sets, the refinement
type <code class="docutils literal notranslate"><span class="pre">x:t{</span> <span class="pre">p</span> <span class="pre">}</span></code> <em>refines</em> the set corresponding to <code class="docutils literal notranslate"><span class="pre">t</span></code> by the
predicate <code class="docutils literal notranslate"><span class="pre">p</span></code>, i.e., the <code class="docutils literal notranslate"><span class="pre">x:t{</span> <span class="pre">p</span> <span class="pre">}</span></code> denotes a subset of <code class="docutils literal notranslate"><span class="pre">t</span></code>, so, of
course <code class="docutils literal notranslate"><span class="pre">x:t{</span> <span class="pre">p</span> <span class="pre">}</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<p>The other direction is a bit more subtle: <code class="docutils literal notranslate"><span class="pre">x:t{</span> <span class="pre">p</span> <span class="pre">}</span></code> is only a subtype
of <code class="docutils literal notranslate"><span class="pre">p</span></code>, for those terms <code class="docutils literal notranslate"><span class="pre">e</span></code> that validate <code class="docutils literal notranslate"><span class="pre">p</span></code>. You’re probably also
wondering about how to prove that <code class="docutils literal notranslate"><span class="pre">p[e/x]</span></code> evaluates to <code class="docutils literal notranslate"><span class="pre">true</span></code>—this
<a class="reference internal" href="#tutorial-refinements"><span class="std std-ref">part of the tutorial</span></a> should provide some
answers. But, the short version is that F*, by default, uses an SMT
solver to prove such fact, though you can also use tactics and other
techniques to do so. More information can be found
<a class="reference internal" href="#mental-model-refinements"><span class="std std-ref">here</span></a>.</p>
<div class="section" id="an-example">
<h5>An example<a class="headerlink" href="#an-example" title="Permalink to this headline">¶</a></h5>
<p>Given <code class="docutils literal notranslate"><span class="pre">x:even</span></code>, consider typechecking <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">odd</span></code>; it takes a few
steps:</p>
<ol class="arabic simple">
<li><p>The operator <code class="docutils literal notranslate"><span class="pre">+</span></code> expects both its arguments to have type <code class="docutils literal notranslate"><span class="pre">int</span></code> and
returns an <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p></li>
<li><p>To prove that the first argument <code class="docutils literal notranslate"><span class="pre">x:even</span></code> is a valid argument for
<code class="docutils literal notranslate"><span class="pre">+</span></code>, we use refinement subtyping to eliminate the refinement and
obtain <code class="docutils literal notranslate"><span class="pre">x:int</span></code>. The second argument <code class="docutils literal notranslate"><span class="pre">1:int</span></code> already has the
required type. Thus, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">int</span></code>.</p></li>
<li><p>To conclude that <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">odd</span></code>, we need to introduce a refinement
type, by proving that the refinement predicate of <code class="docutils literal notranslate"><span class="pre">odd</span></code> evaluates
to true, i.e., <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">=</span> <span class="pre">1</span></code>. This is provable by SMT, since we
started with the knowledge that <code class="docutils literal notranslate"><span class="pre">x</span></code> is even.</p></li>
</ol>
<p>As such, F* applies subtyping repeatedly to introduce and eliminate
refinement types, applying it multiple times even to check a simple
term like <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">odd</span></code>.</p>
</div>
</div>
</div>
<div class="section" id="function-types-or-arrows">
<h3>Function types or arrows<a class="headerlink" href="#function-types-or-arrows" title="Permalink to this headline">¶</a></h3>
<p>Functions are the main abstraction facility of any functional language
and their types are, correspondigly, the main specificational
construct.</p>
<div class="section" id="total-dependent-functions">
<h4>Total dependent functions<a class="headerlink" href="#total-dependent-functions" title="Permalink to this headline">¶</a></h4>
<p>In its most basic form, function types have the shape:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span><span class="n">t0</span> <span class="o">-&gt;</span> <span class="n">t1</span>
</pre></div>
</div>
<p>This is the type of a function that</p>
<ol class="arabic simple">
<li><p>receives an argument <code class="docutils literal notranslate"><span class="pre">e</span></code> of type <code class="docutils literal notranslate"><span class="pre">t0</span></code>, and</p></li>
<li><p>always returns a value of type <code class="docutils literal notranslate"><span class="pre">t1[e</span> <span class="pre">/</span> <span class="pre">x]</span></code>, i.e., the type of the
returned value depends on the argument <code class="docutils literal notranslate"><span class="pre">e</span></code>.</p></li>
</ol>
<p>It’s worth emphasizing how this differs from function types in other
languages.</p>
<ul class="simple">
<li><p>F*’s function type are dependent—the type of the result depends on
the argument. For example, we can write a function that returns a
<code class="docutils literal notranslate"><span class="pre">bool</span></code> when applied to an even number and returns a <code class="docutils literal notranslate"><span class="pre">string</span></code> when
applied to an odd number.</p></li>
<li><p>In F*’s core language, all functions are total, i.e., a function
call always terminates after consuming a finite but unbounded amount
of resources.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>That said, on any given computer, it is possible for a function
call to fail to return due to resource exhaustion, e.g., running
out of memory. Later, as we look at <a class="reference internal" href="#id2"><span class="std std-ref">effects</span></a>, we
will see that F* also supports writing non-terminating functions.</p>
</div>
<div class="section" id="some-examples-and-common-notation">
<h5>Some examples and common notation<a class="headerlink" href="#some-examples-and-common-notation" title="Permalink to this headline">¶</a></h5>
<ol class="arabic">
<li><p>Functions are <em>curried</em>. Functions that take multiple arguments are
written as functions that take the first argument and return a
function that takes the next argument and so on. For instance, the
type of integer addition is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">:</span> <span class="n">x</span><span class="p">:</span><span class="nb">int</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="p">:</span><span class="nb">int</span> <span class="o">-&gt;</span> <span class="nb">int</span>
</pre></div>
</div>
</li>
<li><p>Not all functions are dependent and the name of the argument can be
omitted when it is not needed. For example, here’s a more concise
way to write the type of <code class="docutils literal notranslate"><span class="pre">(+)</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="o">-&gt;</span> <span class="nb">int</span>
</pre></div>
</div>
</li>
<li><p>Function types can be mixed with refinement types. For instance,
here’s the type of integer division—the refinement on the divisor
forbids division-by-zero errors:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="p">(</span><span class="o">/</span><span class="p">)</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">divisor</span><span class="p">:</span><span class="nb">int</span> <span class="p">{</span> <span class="n">divisor</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span> <span class="p">})</span> <span class="o">-&gt;</span> <span class="nb">int</span>
</pre></div>
</div>
</li>
<li><p>Dependence between the arguments and the result type can be used to
state relationships among them. For instance, there are several
types for the function <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">incr</span> <span class="pre">=</span> <span class="pre">(fun</span> <span class="pre">(x:int)</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1)</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="n">incr</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">-&gt;</span> <span class="nb">int</span>
<span class="n">val</span> <span class="n">incr</span> <span class="p">:</span> <span class="n">x</span><span class="p">:</span><span class="nb">int</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">}</span>
<span class="n">val</span> <span class="n">incr</span> <span class="p">:</span> <span class="n">x</span><span class="p">:</span><span class="nb">int</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span>
</pre></div>
</div>
<p>The first type <code class="docutils literal notranslate"><span class="pre">(int</span> <span class="pre">-&gt;</span> <span class="pre">int)</span></code> is its traditional type in languages
like OCaml.</p>
<p>The second type <code class="docutils literal notranslate"><span class="pre">(x:int</span> <span class="pre">-&gt;</span> <span class="pre">y:int{y</span> <span class="pre">&gt;</span> <span class="pre">x})</span></code> states that the returned
value <code class="docutils literal notranslate"><span class="pre">y</span></code> is greater than the argument <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>The third type is the most precise: <code class="docutils literal notranslate"><span class="pre">(x:int</span> <span class="pre">-&gt;</span> <span class="pre">y:int{y</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1})</span></code>
states that the result <code class="docutils literal notranslate"><span class="pre">y</span></code> is exactly the increment of the argument
<code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</li>
<li><p>It’s often convenient to add refinements on arguments in a
dependent function type. For instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="n">f</span> <span class="p">:</span> <span class="n">x</span><span class="p">:(</span><span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="p">})</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="p">:(</span><span class="n">y</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="p">})</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="p">}</span>
</pre></div>
</div>
<p>Since this style is so common, and it is inconvenient to have to
bind two names for the parameters <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>, F* allows (and
encourages) you to write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="n">f</span> <span class="p">:</span> <span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">z</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>To emphasize that functions in F*’s core are total functions (i.e.,
they always return a result), we sometimes annotate the result type
with the effect label “<code class="docutils literal notranslate"><span class="pre">Tot</span></code>”. This label is optional, but
especially as we learn about <a class="reference internal" href="#id2"><span class="std std-ref">effects</span></a>, emphasizing
that some functions have no effects via the <code class="docutils literal notranslate"><span class="pre">Tot</span></code> label is
useful. For example, one might typically write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="n">f</span> <span class="p">:</span> <span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">Tot</span> <span class="p">(</span><span class="n">z</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="p">})</span>
</pre></div>
</div>
<p>adding a <code class="docutils literal notranslate"><span class="pre">Tot</span></code> annotation on the last arrow, to indicate that the
function has no side effects. One could also write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="n">f</span> <span class="p">:</span> <span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">Tot</span> <span class="p">(</span><span class="n">y</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">Tot</span> <span class="p">(</span><span class="n">z</span><span class="p">:</span><span class="nb">int</span><span class="p">{</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="p">}))</span>
</pre></div>
</div>
<p>adding an annotation on the intermediate arrow, though this is not
customary.</p>
</li>
</ol>
<p>Please refer to the section on <a class="reference internal" href="#implicits"><span class="std std-ref">Implicit Arguments</span></a>,
where we explain the full syntax of binders, in function abstractions
and types.</p>
</div>
</div>
</div>
<div class="section" id="type-the-type-of-types">
<h3>Type: The type of types<a class="headerlink" href="#type-the-type-of-types" title="Permalink to this headline">¶</a></h3>
<p>One characteristic of F* (and many other dependently typed languages)
is that it treats programs and their types uniformly, all within a
single syntactic class. A type system in this style is sometimes
called a <em>Pure Type System</em> or <a class="reference external" href="https://en.wikipedia.org/wiki/Pure_type_system">PTS</a>.</p>
<p>In F* (as in other PTSs) types have types too, functions can take
types as arguments and return types as results, etc. In particular,
the type of a type is <code class="docutils literal notranslate"><span class="pre">Type</span></code>, e.g., <code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">:</span> <span class="pre">Type</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">:</span> <span class="pre">Type</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span>
<span class="pre">-&gt;</span> <span class="pre">int</span> <span class="pre">:</span> <span class="pre">Type</span></code> etc. In fact, even <code class="docutils literal notranslate"><span class="pre">Type</span></code> has a type—as we’ll see in
the subsection on <a class="reference internal" href="#id1"><span class="std std-ref">universes</span></a>.</p>
<div class="section" id="parametric-polymorphism-or-generics">
<h4>Parametric polymorphism or generics<a class="headerlink" href="#parametric-polymorphism-or-generics" title="Permalink to this headline">¶</a></h4>
<p>Most modern typed languages provide a way to write programs with
generic types. For instance, C# and Java provide generics, C++ has
templates, and languages like OCaml and Haskell have several kinds of
polymorphic types.</p>
<p>In F*, writing functions that are generic or polymorphic in types
arises naturally as a special case of dependent function types. For
example, here’s a polymorphic identity function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="nb">id</span> <span class="p">:</span> <span class="n">a</span><span class="p">:</span><span class="n">Type</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">fun</span> <span class="n">a</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span>
</pre></div>
</div>
<p>There are a several things to note here:</p>
<ul class="simple">
<li><p>The type of <code class="docutils literal notranslate"><span class="pre">id</span></code> is a dependent function type, with two
arguments. The first argument is <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">Type</span></code>; the second argument is
a term of type <code class="docutils literal notranslate"><span class="pre">a</span></code>; and the result also has the same type <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p></li>
<li><p>The definition of <code class="docutils literal notranslate"><span class="pre">id</span></code> is a lambda term with two arguments <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span>
<span class="pre">Type</span></code> (corresponding to the first argument type) and <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">a</span></code>. The
function returns <code class="docutils literal notranslate"><span class="pre">x</span></code>—it’s an identity function on the second
argument.</p></li>
</ul>
<p>Here are some equivalent ways to write it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="nb">id</span> <span class="o">=</span> <span class="n">fun</span> <span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="n">Type</span><span class="p">)</span> <span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&lt;</span><span class="p">:</span> <span class="n">a</span>
<span class="n">let</span> <span class="nb">id</span> <span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="n">Type</span><span class="p">)</span> <span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="n">a</span><span class="p">)</span> <span class="p">:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">x</span>
</pre></div>
</div>
<p>To call <code class="docutils literal notranslate"><span class="pre">id</span></code>, one can apply and check its type as shown:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">id</span> <span class="nb">bool</span> <span class="n">true</span> <span class="p">:</span> <span class="nb">bool</span>
<span class="nb">id</span> <span class="nb">bool</span> <span class="n">false</span> <span class="p">:</span> <span class="nb">bool</span>
<span class="nb">id</span> <span class="nb">int</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">:</span> <span class="nb">int</span>
<span class="nb">id</span> <span class="n">nat</span> <span class="mi">17</span> <span class="p">:</span> <span class="n">nat</span>
<span class="nb">id</span> <span class="n">string</span> <span class="s2">&quot;hello&quot;</span> <span class="p">:</span> <span class="n">string</span>
<span class="nb">id</span> <span class="p">(</span><span class="nb">int</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">)</span> <span class="p">(</span><span class="n">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="mi">0</span> <span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Exercises</p>
<p>Try completing the following programs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">apply</span> <span class="p">:</span> <span class="n">a</span><span class="p">:</span><span class="n">Type</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">:</span><span class="n">Type</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">fill</span> <span class="n">me</span> <span class="ow">in</span><span class="o">&gt;</span>
<span class="n">let</span> <span class="n">compose</span> <span class="p">:</span> <span class="n">a</span><span class="p">:</span><span class="n">Type</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">:</span><span class="n">Type</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">:</span><span class="n">Type</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">fill</span> <span class="n">me</span> <span class="ow">in</span><span class="o">&gt;</span>
<span class="n">let</span> <span class="n">twice</span> <span class="p">:</span> <span class="o">&lt;</span><span class="n">fill</span> <span class="n">me</span> <span class="ow">in</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">fun</span> <span class="n">a</span> <span class="n">f</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">compose</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="n">f</span> <span class="n">f</span> <span class="n">x</span>
</pre></div>
</div>
</div>
<p>It’s quite tedious to have to explicitly provide that first type
argument to <code class="docutils literal notranslate"><span class="pre">id</span></code>. Implicit arguments and type inference will help, as
we’ll see in <a class="reference internal" href="#inference"><span class="std std-ref">a later section</span></a>.</p>
</div>
</div>
<div class="section" id="type-inference-basics">
<h3>Type inference: Basics<a class="headerlink" href="#type-inference-basics" title="Permalink to this headline">¶</a></h3>
<p id="inference">Like many other languages in the tradition of
<a class="reference external" href="https://en.wikipedia.org/wiki/ML_%28programming_language%29">Milner’s ML</a>,
type inference is a central component in F*’s design.</p>
<p>You may be used to type inference in other languages, where one can
leave out type annotations (e.g., on variables, or when using
type-polymorphic (aka generic) functions) and the compiler determines
an appropriate type based on the surrounding program context. F*’s
type inference certainly includes such a feature, but is considerably
more powerful. Like in other dependently typed language, F*’s
inference engine is based on <a class="reference external" href="https://en.wikipedia.org/wiki/Unification_(computer_science)#Higher-order_unification">higher-order unification</a>
and can be used to infer arbitrary fragments of program text, not just
type annotations on variables.</p>
<p>Let’s consider our simple example of the definition and use of the
identity function again:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="nb">id</span> <span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="n">Type</span><span class="p">)</span> <span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="n">a</span><span class="p">)</span> <span class="p">:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">x</span>

<span class="nb">id</span> <span class="nb">bool</span> <span class="n">true</span> <span class="p">:</span> <span class="nb">bool</span>
<span class="nb">id</span> <span class="nb">bool</span> <span class="n">false</span> <span class="p">:</span> <span class="nb">bool</span>
<span class="nb">id</span> <span class="nb">int</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">:</span> <span class="nb">int</span>
<span class="nb">id</span> <span class="n">nat</span> <span class="mi">17</span> <span class="p">:</span> <span class="n">nat</span>
<span class="nb">id</span> <span class="n">string</span> <span class="s2">&quot;hello&quot;</span> <span class="p">:</span> <span class="n">string</span>
<span class="nb">id</span> <span class="p">(</span><span class="nb">int</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">)</span> <span class="p">(</span><span class="n">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="mi">0</span> <span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p>Instead of explicitly providing that first type argument when applying
<code class="docutils literal notranslate"><span class="pre">id</span></code>, one could write it as follows, replacing the type arguments with
an underscore <code class="docutils literal notranslate"><span class="pre">_</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">id</span> <span class="n">_</span> <span class="n">true</span> <span class="p">:</span> <span class="nb">bool</span>
<span class="nb">id</span> <span class="n">_</span> <span class="n">false</span> <span class="p">:</span> <span class="nb">bool</span>
<span class="nb">id</span> <span class="n">_</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">:</span> <span class="nb">int</span>
<span class="nb">id</span> <span class="n">_</span> <span class="mi">17</span> <span class="p">:</span> <span class="n">nat</span>
<span class="nb">id</span> <span class="n">_</span> <span class="s2">&quot;hello&quot;</span> <span class="p">:</span> <span class="n">string</span>
<span class="nb">id</span> <span class="n">_</span> <span class="p">(</span><span class="n">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="mi">0</span> <span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p>The underscore symbols is a wildcard, or a hole in program, and it’s
the job of the F* typechecker to fill in the hole.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Program holes are a very powerful concept and form the basis of
Meta-F*, the metaprogramming and tactics framework embedded in
F*—we’ll see more about holes in a <a class="reference internal" href="../index.html#metafstar"><span class="std std-ref">later
section</span></a>.</p>
</div>
<div class="section" id="implicit-arguments">
<h4>Implicit arguments<a class="headerlink" href="#implicit-arguments" title="Permalink to this headline">¶</a></h4>
<p id="implicits">Since it’s tedious to write an <code class="docutils literal notranslate"><span class="pre">_</span></code> everywhere, F* has a notion of
<em>implicit arguments</em>. That is, when defining a function, one can add
annotations to indicate that certain arguments can be omitted at call
sites and left for the typechecker to infer automatically.</p>
<p>For example, one could write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="nb">id</span> <span class="p">(</span><span class="c1">#a:Type) (x:a) : a = x</span>
</pre></div>
</div>
<p>decorating the first argument <code class="docutils literal notranslate"><span class="pre">a</span></code> with a <code class="docutils literal notranslate"><span class="pre">#</span></code>, to indicate that it is
an implicit argument. Then at call sites, one can simply write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">id</span> <span class="n">true</span>
<span class="nb">id</span> <span class="mi">0</span>
<span class="nb">id</span> <span class="p">(</span><span class="n">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="mi">0</span>
</pre></div>
</div>
<p>And F* will figure out instantiations for the missing first argument
to <code class="docutils literal notranslate"><span class="pre">id</span></code>.</p>
<p>In some cases, it may be useful to actually provide an implicit
argument explicitly, rather than relying on the F* to pick one. For
example, one could write the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">id</span> <span class="c1">#nat 0</span>
<span class="nb">id</span> <span class="c1">#(x:int{x == 0}) 0</span>
<span class="nb">id</span> <span class="c1">#(x:int{x &lt;&gt; 1}) 0</span>
</pre></div>
</div>
<p>In each case, we provide the first argument of <code class="docutils literal notranslate"><span class="pre">id</span></code> explicitly, by
preceding it with a <code class="docutils literal notranslate"><span class="pre">#</span></code> sign, which instructs F* to take the user’s
term rather than generating a hole and trying to fill it.</p>
</div>
</div>
<div class="section" id="universes">
<h3>Universes<a class="headerlink" href="#universes" title="Permalink to this headline">¶</a></h3>
<p id="id1">As mentioned before, every well-typed term in F* has a type, and this
is true of the type <code class="docutils literal notranslate"><span class="pre">Type</span></code> itself. In some languages that are
designed only for programming rather than both programs and proofs,
the type of <code class="docutils literal notranslate"><span class="pre">Type</span></code> is itself <code class="docutils literal notranslate"><span class="pre">Type</span></code>, a kind of circularity known
as <a class="reference external" href="https://en.wikipedia.org/wiki/Impredicativity">impredicativity</a>. This circularity
leads to paradoxes and can make a logic inconsistent.</p>
<p>As such, F*, like many other dependently typed systems, employ a
system of <em>universes</em>. The type <code class="docutils literal notranslate"><span class="pre">Type</span></code> actually comes in (countably)
infinite variants, written <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">u#0</span></code>, <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">u#1</span></code>, <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">u#2</span></code>,
etc. The <code class="docutils literal notranslate"><span class="pre">u#i</span></code> annotation following the <code class="docutils literal notranslate"><span class="pre">Type</span></code> is called a
<em>universe level</em>, where <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">u#i</span></code> has type <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">u#(i</span> <span class="pre">+</span> <span class="pre">1)</span></code>. One
way to think of it is the each universe level contains an entire copy
of <code class="docutils literal notranslate"><span class="pre">F*</span></code>’s type system, with higher universes being large enough to
accommodate copies of the systems available at all lower levels.</p>
<p>This may seem a bit mind-bending at first. And, indeed, the universe
system of F* can often be ignored, since F* will infer universes
levels, e.g., one can just write <code class="docutils literal notranslate"><span class="pre">Type</span></code> instead of picking a
specific universe level. That said, occasionally, the universe
constraints will make themselves known and preventy you from doing
certain things that can break consistency. Nevertheless, universes are
a crucial feature that allow F* programs to abstract over nearly all
elements of the language (e.g., one can write functions from types to
types, or store types within data structures) while remaining
logically consistent.</p>
<p>F*’s type system is universe polymorphic, meaning that by default, a defin</p>
</div>
<div class="section" id="syntax-of-binders">
<h3>Syntax of binders<a class="headerlink" href="#syntax-of-binders" title="Permalink to this headline">¶</a></h3>
<p>Having informally introduced implicit arguments, we can now present a
first take at the syntax of binders in F*.</p>
<p><strong>Binding occurrences</strong>: A binding occurence <cite>b</cite> of a variable
introduces a variable in a scope and is associated with one of several
language constructs, including a lambda abstraction, a refinement
type, a let binding, etc. Each binding occurrence is in one of several
forms:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The form <code class="docutils literal notranslate"><span class="pre">x:t</span></code>, declaring a variable <code class="docutils literal notranslate"><span class="pre">x</span></code> at type <code class="docutils literal notranslate"><span class="pre">t</span></code></p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">#x:t</span></code>, indicating that the binding is for an implicit
argument <code class="docutils literal notranslate"><span class="pre">x</span></code> of type <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p></li>
</ol>
</div></blockquote>
<p>In many cases the type annotation on a binder can be omitted,</p>
<p>Later, we will see additional forms of binding occurrences, including
versions that associate attributes with binders and others with
various forms of type-inference hints.</p>
<p><strong>Introducing binders</strong>: The syntax <code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">(b1)</span> <span class="pre">...</span> <span class="pre">(bn)</span> <span class="pre">-&gt;</span> <span class="pre">t</span></code>
introduces a lambda abstraction, whereas <code class="docutils literal notranslate"><span class="pre">b1</span> <span class="pre">-&gt;</span> <span class="pre">..</span> <span class="pre">bn</span> <span class="pre">-&gt;</span> <span class="pre">t</span></code> is the
shape of a function type.</p>
</div>
<div class="section" id="decidable-equality-and-eqtype">
<h3>Decidable equality and <cite>eqtype</cite><a class="headerlink" href="#decidable-equality-and-eqtype" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="let-bindings">
<h3>Let bindings<a class="headerlink" href="#let-bindings" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="inductive-type-definitions">
<h3>Inductive type definitions<a class="headerlink" href="#inductive-type-definitions" title="Permalink to this headline">¶</a></h3>
<div class="section" id="discriminators">
<span id="tuples"></span><h4>Discriminators<a class="headerlink" href="#discriminators" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="projectors">
<h4>Projectors<a class="headerlink" href="#projectors" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="equality">
<h4>Equality<a class="headerlink" href="#equality" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="positivity">
<h4>Positivity<a class="headerlink" href="#positivity" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="universe-constraints">
<h4>Universe constraints<a class="headerlink" href="#universe-constraints" title="Permalink to this headline">¶</a></h4>
</div>
</div>
<div class="section" id="pattern-matching">
<h3>Pattern matching<a class="headerlink" href="#pattern-matching" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="recursive-definitions-and-termination">
<h3>Recursive definitions and termination<a class="headerlink" href="#recursive-definitions-and-termination" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="refinement-types">
<h3>Refinement Types<a class="headerlink" href="#refinement-types" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="proof-irrelevance-squash-types-and-classical-logic">
<h3>Proof irrelevance, squash types and classical logic<a class="headerlink" href="#proof-irrelevance-squash-types-and-classical-logic" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="misc">
<h3>Misc<a class="headerlink" href="#misc" title="Permalink to this headline">¶</a></h3>
<div class="section" id="evaluation-strategy">
<h4>Evaluation strategy<a class="headerlink" href="#evaluation-strategy" title="Permalink to this headline">¶</a></h4>
</div>
</div>
</div>
<div class="section" id="effects">
<span id="ascriptions"></span><h2>Effects<a class="headerlink" href="#effects" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="modules-and-interfaces">
<span id="id2"></span><h2>Modules and Interfaces<a class="headerlink" href="#modules-and-interfaces" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound" id="modules">
</div>
</div>
<div class="section" id="a-mental-model-of-the-f-typechecker">
<h2>A Mental Model of the F* Typechecker<a class="headerlink" href="#a-mental-model-of-the-f-typechecker" title="Permalink to this headline">¶</a></h2>
<p id="mental-model-refinements">Dangling</p>
<span class="target" id="tutorial-refinements"></span></div>
</div>


           </div>
           
          </div>
    <!-- <a href="https://github.com/FStarLang/fstar/"> -->
    <!--     <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"> -->
    <!-- </a> -->

          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../PL-pl-foundations.html" class="btn btn-neutral float-right" title="Foundations of Programming Languages" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../part1/part1_ch1.html" class="btn btn-neutral float-left" title="Getting off the ground" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Microsoft Research

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>