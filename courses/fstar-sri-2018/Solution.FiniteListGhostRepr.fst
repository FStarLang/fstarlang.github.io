/// This module is standalone and can be successfully compiled with:
/// krml -no-prefix Solution.FiniteListGhostRepr Solution.FiniteListGhostRepr.fst
module Solution.FiniteListGhostRepr

open FStar.UInt32

/// We define the canonical abbreviations, taking care to shadow ST to make sure
/// we don't end up referring to FStar.ST by accident.
module B = LowStar.Buffer
module U32 = FStar.UInt32
module HS = FStar.HyperStack
module M = LowStar.Modifies
module ST = FStar.HyperStack.ST
module S = FStar.Seq

/// This brings into scope the ``!*`` and ``*=`` operators, which are
/// specifically designed to operate on buffers of size 1, i.e. on pointers.
open LowStar.BufferOps
open FStar.HyperStack.ST
open LowStar.Modifies

/// A finite list `t a` is a pointer to a struct with 3 fields
noeq
type t_struct a = {
  b: B.buffer a;              //An underlying array to hold the elements
  total_length: v:U32.t;      //of fixed maximum size
  first: U32.t;               //the position of the head of the list
}
type t a = B.pointer (t_struct a)

/// To facilitate writing predicates, we define a handy shortcut that is the
/// reflection of the ``!*`` operator at the proof level.
unfold
let deref #a (h: HS.mem) (x: B.pointer a) = B.get h x 0

/// Here's a well-formedness predicate on a finite list `xs: t a`
/// in a given heap `h`
let ok #a (h: HS.mem) (xs: t a) =
  let open FStar.UInt32 in
  B.live h xs /\ //Temporal safety: the reference to the struct is live
  (let x = deref h xs in
   B.live h x.b /\  //Temporal safety: the array within the struct is live
   B.disjoint x.b xs /\ //Anti-aliasing, needed for framing
   B.len x.b = x.total_length /\ //Spatial safety: the total_length field really is the length
   x.first <=^ x.total_length)  //Spatial safety: the first field is within bounds of the array

/// Computing the representation of the mutable finite list
/// as a pure sequence (for use in specification)
let repr #a h (xs:t a{ok h xs}) : GTot (Seq.seq a) =
    let x = deref h xs in
    B.as_seq h (B.gsub x.b x.first (x.total_length -^ x.first))

/// A predicate stating that xs has no elements
let empty #a h (xs: t a{ok h xs}) =
  Seq.equal (repr h xs) Seq.createEmpty

/// A predicate stating that xs has no more capacity
let full #a h (xs: t a{ok h xs}) =
  Seq.length (repr h xs) == U32.v (deref h xs).total_length

/// Your goal is now to write suitable pre- and post-conditions for this
/// function, along with its body. Start with the pre-condition: what is the
/// predicate that will allow us to always pop an element off the front of the
/// list? Then, provide a suitable post-condition that captures both the memory
/// safety and the semantics of the function.
let pop #a (x: t a): Stack a
  (requires fun h -> ok h x /\ ~(empty h x))
  (ensures fun h0 r h1 ->
            ok h1 x
         /\  Seq.equal (repr h1 x) (Seq.tail (repr h0 x))
         /\  r == Seq.head (repr h0 x)
         /\  modifies (loc_union (loc_buffer x)
                                (loc_buffer (deref h0 x).b)) h0 h1)
= let v = !* x in
  let res : a = v.b.(v.first) in
  let next = v.first +^ 1ul in
  x *= {v with first=next};
  res

/// Similar thing with push.
let push #a (x: t a) (e:a) : Stack unit
  (requires fun h -> ok h x /\ ~(full h x))
  (ensures fun h0 _ h1 ->
            ok h1 x
         /\  Seq.equal (repr h1 x) (Seq.cons e (repr h0 x))
         /\  modifies (loc_union (loc_buffer x)
                                (loc_buffer (deref h0 x).b)) h0 h1)
= let v = !* x in
  let next = v.first -^ 1ul in
  v.b.(next) <- e;
  x *= {v with first=next}

unfold inline_for_extraction
let malloc #a (init: a) len = B.malloc #a HS.root init len

/// Finally, the create function. Find a suitable pre-condition, and reflect the
/// semantics and memory changes in the post-condition.
let create #a (def:a) (len:U32.t) : ST (t a)
  (requires fun h -> len <> 0ul)
  (ensures fun h0 r h1 ->
            ok h1 r
          /\ Seq.equal (repr h1 r) Seq.createEmpty
          /\ (deref h1 r).total_length = len
          /\ modifies loc_none h0 h1)
 = let buf = {
       b = malloc def len;
       first = len;
       total_length = len
   } in
   B.malloc FStar.Monotonic.HyperHeap.root buf 1ul

module I32 = FStar.Int32
/// This main function forces suitable monomorphizations to be generated by KreMLin.
let main (): St I32.t =
  let l = create 1l 120ul in
  push l 0l;
  pop l
