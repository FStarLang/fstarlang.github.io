<!DOCTYPE html>
<html class="writer-html5" lang="english" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Low* language &mdash; The KaRaMeL user manual  documentation</title>
      <link rel="stylesheet" type="text/css" href="static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="static/css/theme.css?v=86f27845" />

  
  
        <script src="static/jquery.js?v=8dae8fb0"></script>
        <script src="static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="static/documentation_options.js?v=df973ab0"></script>
        <script src="static/doctools.js?v=888ff710"></script>
        <script src="static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Low* libraries" href="TocLibraries.html" />
    <link rel="prev" title="Tooling and project setup" href="Setup.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            The KaRaMeL user manual
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Setup.html">Tooling and project setup</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Low* language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#a-crash-course-on-low">A crash course on Low*</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#base-types">Base types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#control-flow">Control-flow</a></li>
<li class="toctree-l3"><a class="reference internal" href="#allocations">Allocations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#struct-types">Struct types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#constants">Constants</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#extensions-to-low">Extensions to Low*</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#equalities-monomorphization">Equalities monomorphization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inductives-as-tagged-unions-pattern-matching-compilation">Inductives as tagged unions; pattern-matching compilation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-type-monomorphization">Data type monomorphization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pattern-matches-compilation">Pattern matches compilation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-monomorphization">Function monomorphization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#higher-order-with-functions-pointers">Higher order with functions pointers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#non-constant-globals">Non-constant globals</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#code-quality-improvements">Code quality improvements</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#unused-argument-elimination">Unused argument elimination</a></li>
<li class="toctree-l3"><a class="reference internal" href="#temporary-variable-elimination">Temporary variable elimination</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tuple-elimination">Tuple elimination</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dead-code-elimination">Dead code elimination</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unused-local-variable-elimination">Unused local variable elimination</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functional-update-optimization">Functional update optimization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#some-non-low-code">Some non-Low* code</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="TocLibraries.html">Low* libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="TocExamples.html">Low* examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="Toy.html">A toy project for learning Low*</a></li>
<li class="toctree-l1"><a class="reference internal" href="AdvancedTips.html">Advanced tips &amp; tricks</a></li>
<li class="toctree-l1"><a class="reference internal" href="AdvancedTopics.html">Advanced KaRaMeL topics</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">The KaRaMeL user manual</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Low* language</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/Core.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="low-language">
<h1>Low* language<a class="headerlink" href="#low-language" title="Link to this heading"></a></h1>
<p>Low*, as formalized and presented in this <a class="reference external" href="https://arxiv.org/abs/1703.00053">paper</a>,
is the first-order lambda calculus. Base types are booleans and
fixed-width integers. Low* has a primitive notion of <em>arrays</em> (also known as
buffers, although that terminology is being phased out) and pointer
arithmetic within buffer bounds. In the formalization, structures are only
valid when allocated within a buffer.</p>
<p>This section describes Low* by example, showing valid and invalid
constructs, to give the reader a good grasp of what syntactic subset of the
F* language constitutes valid Low*.</p>
<section id="a-crash-course-on-low">
<h2>A crash course on Low*<a class="headerlink" href="#a-crash-course-on-low" title="Link to this heading"></a></h2>
<section id="base-types">
<h3>Base types<a class="headerlink" href="#base-types" title="Link to this heading"></a></h3>
<p>This is only a brief introduction -- you should peruse existing bodies of code
(HACL*, EverCrypt, EverQuic) to get a good grasp of what is supported.</p>
<p>Low*'s base types are machine integers, booleans, units.</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="n">square</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="nn">UInt32</span><span class="p">.</span><span class="n">t</span><span class="o">):</span> <span class="nn">UInt32</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span>
  <span class="kd">let</span> <span class="k">open</span> <span class="nn">FStar</span><span class="p">.</span><span class="nc">UInt32</span> <span class="k">in</span>
  <span class="n">x</span> <span class="o">*%^</span> <span class="n">x</span>
</pre></div>
</div>
<p>This, quite unexcitingly, compiles to the following C code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">square</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="control-flow">
<h3>Control-flow<a class="headerlink" href="#control-flow" title="Link to this heading"></a></h3>
<p>There are no restrictions on control-flow. Recursive functions are supported but
discouraged as you may be enjoying good performance only using a modern
compiler. (See further sections for loops.)</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="n">abs</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="nn">Int32</span><span class="p">.</span><span class="n">t</span><span class="o">):</span> <span class="nc">Pure</span> <span class="nn">Int32</span><span class="p">.</span><span class="n">t</span>
  <span class="o">(</span><span class="k">requires</span> <span class="nn">Int32</span><span class="p">.</span><span class="n">v</span> <span class="n">x</span> <span class="o">&lt;&gt;</span> <span class="nn">Int</span><span class="p">.</span><span class="n">min_int</span> <span class="mi">32</span><span class="o">)</span>
  <span class="o">(</span><span class="k">ensures</span> <span class="k">fun</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="nn">Int32</span><span class="p">.</span><span class="n">v</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">=</span>
  <span class="kd">let</span> <span class="k">open</span> <span class="nn">FStar</span><span class="p">.</span><span class="nc">Int32</span> <span class="k">in</span>
  <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=^</span> <span class="mi">0</span><span class="n">l</span> <span class="k">then</span>
    <span class="n">x</span>
  <span class="k">else</span>
    <span class="mi">0</span><span class="n">l</span> <span class="o">-^</span> <span class="n">x</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int32_t</span><span class="w"> </span><span class="nf">abs</span><span class="p">(</span><span class="kt">int32_t</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="p">(</span><span class="kt">int32_t</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="k">else</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">int32_t</span><span class="p">)</span><span class="mi">0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="allocations">
<h3>Allocations<a class="headerlink" href="#allocations" title="Link to this heading"></a></h3>
<p>Low* models stack allocation, which is covered in <a class="reference internal" href="Libraries.html#buffer-library"><span class="std std-ref">The buffer library</span></a> below.
For now, you must use explicit push/pop combinators that model as the level of
the effect system the fact that a new stack frame exists and that all
allocations should be scoped to the lifetime of that stack frame. The <code class="docutils literal notranslate"><span class="pre">Stack</span></code>
effect forces you to preserve the structure of the stack.</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="n">on_the_stack</span> <span class="bp">()</span><span class="o">:</span> <span class="nc">Stack</span> <span class="nn">UInt64</span><span class="p">.</span><span class="n">t</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="bp">True</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="bp">True</span><span class="o">)</span> <span class="o">=</span>
  <span class="n">push_frame</span> <span class="bp">()</span><span class="o">;</span>
  <span class="kd">let</span> <span class="n">b</span> <span class="o">=</span> <span class="nn">B</span><span class="p">.</span><span class="n">alloca</span> <span class="mi">0</span><span class="n">UL</span> <span class="mi">64</span><span class="n">ul</span> <span class="k">in</span>
  <span class="n">b</span><span class="o">.(</span><span class="mi">0</span><span class="n">ul</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="mi">32</span><span class="n">UL</span><span class="o">;</span>
  <span class="kd">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">b</span><span class="o">.(</span><span class="mi">0</span><span class="n">ul</span><span class="o">)</span> <span class="k">in</span>
  <span class="n">pop_frame</span> <span class="bp">()</span><span class="o">;</span>
  <span class="n">r</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint64_t</span><span class="w"> </span><span class="nf">on_the_stack</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">64U</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0U</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="n">b</span><span class="p">[</span><span class="mi">0U</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="mi">32U</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0U</span><span class="p">];</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Low* supports heap allocation.</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="n">on_the_heap</span> <span class="bp">()</span><span class="o">:</span> <span class="nc">St</span> <span class="nn">UInt64</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span>
  <span class="kd">let</span> <span class="n">b</span> <span class="o">=</span> <span class="nn">B</span><span class="p">.</span><span class="n">malloc</span> <span class="nn">HyperStack</span><span class="p">.</span><span class="n">root</span> <span class="mi">0</span><span class="n">UL</span> <span class="mi">64</span><span class="n">ul</span> <span class="k">in</span>
  <span class="n">b</span><span class="o">.(</span><span class="mi">0</span><span class="n">ul</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="mi">32</span><span class="n">UL</span><span class="o">;</span>
  <span class="kd">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">b</span><span class="o">.(</span><span class="mi">0</span><span class="n">ul</span><span class="o">)</span> <span class="k">in</span>
  <span class="nn">B</span><span class="p">.</span><span class="n">free</span> <span class="n">b</span><span class="o">;</span>
  <span class="n">r</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint64_t</span><span class="w"> </span><span class="nf">on_the_heap</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KRML_HOST_CALLOC</span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="mi">64U</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">));</span>
<span class="w">  </span><span class="n">b</span><span class="p">[</span><span class="mi">0U</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="mi">32U</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0U</span><span class="p">];</span>
<span class="w">  </span><span class="n">KRML_HOST_FREE</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="struct-types">
<h3>Struct types<a class="headerlink" href="#struct-types" title="Link to this heading"></a></h3>
<p>Flat records are part of the original paper formalization, and are
translated as regular C <code class="docutils literal notranslate"><span class="pre">struct</span></code>s.</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="n">uint128</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">low</span><span class="o">:</span> <span class="nn">UInt64</span><span class="p">.</span><span class="n">t</span><span class="o">;</span>
  <span class="n">high</span><span class="o">:</span> <span class="nn">UInt64</span><span class="p">.</span><span class="n">t</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">uint128_s</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">low</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">high</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">uint128</span><span class="p">;</span>
</pre></div>
</div>
<p>In the original paper, structs may be allocated within buffers.</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="n">uint128_alloc</span> <span class="o">(</span><span class="n">h</span> <span class="n">l</span><span class="o">:</span> <span class="nn">UInt64</span><span class="p">.</span><span class="n">t</span><span class="o">):</span> <span class="nc">St</span> <span class="o">(</span><span class="nn">B</span><span class="p">.</span><span class="n">buffer</span> <span class="n">uint128</span><span class="o">)</span> <span class="o">=</span>
  <span class="nn">B</span><span class="p">.</span><span class="n">malloc</span> <span class="nn">HyperStack</span><span class="p">.</span><span class="n">root</span> <span class="o">({</span> <span class="n">low</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span> <span class="n">high</span> <span class="o">=</span> <span class="n">h</span> <span class="o">})</span> <span class="mi">1</span><span class="n">ul</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">uint128</span><span class="w"> </span><span class="o">*</span><span class="nf">uint128_alloc</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">KRML_CHECK_SIZE</span><span class="p">(</span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="n">uint128</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="mi">1U</span><span class="p">);</span>
<span class="w">  </span><span class="n">uint128</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KRML_HOST_MALLOC</span><span class="p">(</span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="n">uint128</span><span class="p">));</span>
<span class="w">  </span><span class="n">buf</span><span class="p">[</span><span class="mi">0U</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">uint128</span><span class="p">){</span><span class="w"> </span><span class="p">.</span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Still in the original paper, one may access a buffer index, then select a
number of fields.</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="n">uint128_high</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="nn">B</span><span class="p">.</span><span class="n">buffer</span> <span class="n">uint128</span><span class="o">):</span> <span class="nc">Stack</span> <span class="nn">UInt64</span><span class="p">.</span><span class="n">t</span>
  <span class="o">(</span><span class="k">requires</span> <span class="k">fun</span> <span class="n">h</span> <span class="o">-&gt;</span> <span class="nn">B</span><span class="p">.</span><span class="n">live</span> <span class="n">h</span> <span class="n">x</span> <span class="o">/\</span> <span class="nn">B</span><span class="p">.</span><span class="n">length</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">(</span><span class="k">ensures</span> <span class="k">fun</span> <span class="n">h0</span> <span class="n">_</span> <span class="n">h1</span> <span class="o">-&gt;</span> <span class="nn">B</span><span class="p">.</span><span class="n">live</span> <span class="n">h1</span> <span class="n">x</span><span class="o">)</span>
<span class="o">=</span>
  <span class="o">(</span><span class="n">x</span><span class="o">.(</span><span class="mi">0</span><span class="n">ul</span><span class="o">)).</span><span class="n">high</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint64_t</span><span class="w"> </span><span class="nf">uint128_high</span><span class="p">(</span><span class="n">uint128</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="o">-&gt;</span><span class="n">high</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="constants">
<h3>Constants<a class="headerlink" href="#constants" title="Link to this heading"></a></h3>
<p>One may define global constants too, as long as they evaluate to C
constants. As a rough approximation, arithmetic expressions and addresses of
other globals are C constants, but as always, the <a class="reference external" href="http://open-std.org/jtc1/SC22/wg14/www/docs/n1548.pdf">C11 standard</a> is the ultimate
source of truth.</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="n">min_int32</span> <span class="o">=</span> <span class="nn">FStar</span><span class="p">.</span><span class="nn">Int32</span><span class="p">.</span><span class="o">(</span><span class="mi">0</span><span class="n">l</span> <span class="o">-^</span> <span class="mh">0x7fffffff</span><span class="n">l</span> <span class="o">-^</span> <span class="mi">1</span><span class="n">l</span><span class="o">)</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Meta-evaluated by F*</span>
<span class="kt">int32_t</span><span class="w"> </span><span class="n">min_int32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int32_t</span><span class="p">)</span><span class="mi">-2147483648</span><span class="p">;</span>
</pre></div>
</div>
</section>
</section>
<section id="extensions-to-low">
<h2>Extensions to Low*<a class="headerlink" href="#extensions-to-low" title="Link to this heading"></a></h2>
<p>KaRaMeL supports a number of programming patterns beyond the original paper
formalization, which aim to maximize programmer productivity. We now review
the main ones.</p>
<section id="equalities-monomorphization">
<h3>Equalities monomorphization<a class="headerlink" href="#equalities-monomorphization" title="Link to this heading"></a></h3>
<p>One can rely on KaRaMeL to compile F*'s structural equality (the <code class="docutils literal notranslate"><span class="pre">(=)</span></code>
operator) to C functions specialized to each type. Furthermore, the function
below demonstrates the use of a struct type as a value, which is
straightforwardly compiled to a C structure passed by value. Be aware that doing
so has performance implications (see ??).</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="n">uint128_equal</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span><span class="o">:</span> <span class="n">uint128</span><span class="o">)</span> <span class="o">=</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">y</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">__eq__LowStar_uint128</span><span class="p">(</span><span class="n">uint128</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">uint128</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">low</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">low</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">high</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">high</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span><span class="w"> </span><span class="nf">uint128_equal</span><span class="p">(</span><span class="n">uint128</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">uint128</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">__eq__LowStar_uint128</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="inductives-as-tagged-unions-pattern-matching-compilation">
<h3>Inductives as tagged unions; pattern-matching compilation<a class="headerlink" href="#inductives-as-tagged-unions-pattern-matching-compilation" title="Link to this heading"></a></h3>
<p>One may also use F* inductives, knowing that KaRaMeL will compile them as
tagged unions. There are currently five different compilation schemes for data
types that all aim to generate C code that is &quot;as natural&quot; as possible:</p>
<ul class="simple">
<li><p>inductives with a single branch with a single argument are completely
eliminated (e.g. <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">|</span> <span class="pre">Foo:</span> <span class="pre">x:UInt32.t</span> <span class="pre">-&gt;</span> <span class="pre">t</span></code> compiles to <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code>)</p></li>
<li><p>inductives with only constant constructors compile to <code class="docutils literal notranslate"><span class="pre">uint8</span></code> (or a C11 enum
if <code class="docutils literal notranslate"><span class="pre">-fnoshort-enums</span></code>  is used (e.g. <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">|</span> <span class="pre">A</span> <span class="pre">|</span> <span class="pre">B</span></code> compiles to
<code class="docutils literal notranslate"><span class="pre">uint8</span></code>)</p></li>
<li><p>inductives with a single constructor compile to a C struct without a tag (e.g.
<code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">|</span> <span class="pre">Foo:</span> <span class="pre">x:UInt32.t</span> <span class="pre">-&gt;</span> <span class="pre">y:UInt32.t</span> <span class="pre">-&gt;</span> <span class="pre">t</span></code> compiles to <code class="docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">struct</span>
<span class="pre">{</span> <span class="pre">uint32_t</span> <span class="pre">x;</span> <span class="pre">uint32_t</span> <span class="pre">y</span> <span class="pre">}</span> <span class="pre">t</span></code>)</p></li>
<li><p>inductives with a single non-constant constructor compile to a tagged C struct
without a union (e.g. <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">option_int</span> <span class="pre">=</span> <span class="pre">|</span> <span class="pre">None'</span> <span class="pre">|</span> <span class="pre">Some'</span> <span class="pre">of</span> <span class="pre">UInt32.t</span></code>
compiles to <code class="docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">struct</span> <span class="pre">{</span> <span class="pre">uint8_t</span> <span class="pre">option_int_tag;</span> <span class="pre">uint32_t</span> <span class="pre">x</span> <span class="pre">}</span>
<span class="pre">option_int</span></code>)</p></li>
<li><p>all other inductives are compiled as tagged unions.</p></li>
</ul>
<p>For instance, the data type below does not enjoy any optimized compilation
scheme and generates a complete tagged union.</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">noeq</span>
<span class="k">type</span> <span class="n">key</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">Algorithm1</span><span class="o">:</span> <span class="nn">B</span><span class="p">.</span><span class="n">buffer</span> <span class="nn">UInt32</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span>
  <span class="o">|</span> <span class="nc">Algorithm2</span><span class="o">:</span> <span class="nn">B</span><span class="p">.</span><span class="n">buffer</span> <span class="nn">UInt64</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Algorithm1</span><span class="p">,</span><span class="w"> </span><span class="n">Algorithm2</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="n">key_tags</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">key_s</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">key_tags</span><span class="w"> </span><span class="n">tag</span><span class="p">;</span>
<span class="w">  </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">case_Algorithm1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="o">*</span><span class="n">case_Algorithm2</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="p">;</span>
<span class="p">}</span>
<span class="n">key</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="data-type-monomorphization">
<h3>Data type monomorphization<a class="headerlink" href="#data-type-monomorphization" title="Link to this heading"></a></h3>
<p>Generally, KaRaMeL performs a whole-program monomorphization of
parameterized data types. The example below demonstrates this, along with a
&quot;pretty&quot; compilation scheme for the option type that does not involves an
anonymous union.</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="n">abs2</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="nn">Int32</span><span class="p">.</span><span class="n">t</span><span class="o">):</span> <span class="n">option</span> <span class="nn">Int32</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span>
  <span class="kd">let</span> <span class="k">open</span> <span class="nn">FStar</span><span class="p">.</span><span class="nc">Int32</span> <span class="k">in</span>
  <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="n">min_int32</span> <span class="k">then</span>
    <span class="nc">None</span>
  <span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=^</span> <span class="mi">0</span><span class="n">l</span> <span class="k">then</span>
    <span class="nc">Some</span> <span class="n">x</span>
  <span class="k">else</span>
    <span class="nc">Some</span> <span class="o">(</span><span class="mi">0</span><span class="n">l</span> <span class="o">-^</span> <span class="n">x</span><span class="o">)</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">FStar_Pervasives_Native_None</span><span class="p">,</span><span class="w"> </span><span class="n">FStar_Pervasives_Native_Some</span><span class="w"> </span><span class="p">}</span>
<span class="n">FStar_Pervasives_Native_option__int32_t_tags</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">FStar_Pervasives_Native_option__int32_t_s</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">FStar_Pervasives_Native_option__int32_t_tags</span><span class="w"> </span><span class="n">tag</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">FStar_Pervasives_Native_option__int32_t</span><span class="p">;</span>

<span class="n">FStar_Pervasives_Native_option__int32_t</span><span class="w"> </span><span class="nf">abs2</span><span class="p">(</span><span class="kt">int32_t</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">min_int32</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">((</span><span class="n">FStar_Pervasives_Native_option__int32_t</span><span class="p">){</span><span class="w"> </span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FStar_Pervasives_Native_None</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="p">(</span><span class="kt">int32_t</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span>
<span class="w">      </span><span class="p">((</span><span class="n">FStar_Pervasives_Native_option__int32_t</span><span class="p">){</span><span class="w"> </span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FStar_Pervasives_Native_Some</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="k">else</span>
<span class="w">    </span><span class="k">return</span>
<span class="w">      </span><span class="p">(</span>
<span class="w">        </span><span class="p">(</span><span class="n">FStar_Pervasives_Native_option__int32_t</span><span class="p">){</span>
<span class="w">          </span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FStar_Pervasives_Native_Some</span><span class="p">,</span>
<span class="w">          </span><span class="p">.</span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int32_t</span><span class="p">)</span><span class="mi">0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="pattern-matches-compilation">
<h3>Pattern matches compilation<a class="headerlink" href="#pattern-matches-compilation" title="Link to this heading"></a></h3>
<p>Inductives are compiled by KaRaMeL, and so are pattern matches. Note that
for a series of cascading if-then-elses, KaRaMeL has to insert a fallback
else statement, both because the original F* code may be unverified and the
pattern-matching may be incomplete, but also because the C compiler may
trigger an error.</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="n">fail_if</span> <span class="o">#</span><span class="n">a</span> <span class="o">#</span><span class="n">b</span> <span class="o">(</span><span class="n">package</span><span class="o">:</span> <span class="n">a</span> <span class="o">*</span> <span class="o">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">option</span> <span class="n">b</span><span class="o">)):</span> <span class="nc">St</span> <span class="n">b</span> <span class="o">=</span>
  <span class="kd">let</span> <span class="k">open</span> <span class="nn">C</span><span class="p">.</span><span class="nc">Failure</span> <span class="k">in</span>
  <span class="kd">let</span> <span class="k">open</span> <span class="nn">C</span><span class="p">.</span><span class="nc">String</span> <span class="k">in</span>
  <span class="kd">let</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">package</span> <span class="k">in</span>
  <span class="k">match</span> <span class="n">f</span> <span class="n">x</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="o">!$</span><span class="s2">&quot;invalid argument: fail_if&quot;</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int32_t</span>
<span class="nf">fail_if__int32_t_int32_t</span><span class="p">(</span>
<span class="w">  </span><span class="n">K___int32_t_int32_t____FStar_Pervasives_Native_option__int32_t</span><span class="w"> </span><span class="n">package</span>
<span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">package</span><span class="p">.</span><span class="n">fst</span><span class="p">;</span>
<span class="w">  </span><span class="n">FStar_Pervasives_Native_option__int32_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">int32_t</span><span class="w"> </span><span class="n">x0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">package</span><span class="p">.</span><span class="n">snd</span><span class="p">;</span>
<span class="w">  </span><span class="n">FStar_Pervasives_Native_option__int32_t</span><span class="w"> </span><span class="n">scrut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">scrut</span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FStar_Pervasives_Native_None</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">C_Failure_failwith__int32_t</span><span class="p">(</span><span class="s">&quot;invalid argument: fail_if&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">scrut</span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FStar_Pervasives_Native_Some</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scrut</span><span class="p">.</span><span class="n">v</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">else</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">KRML_HOST_PRINTF</span><span class="p">(</span><span class="s">&quot;KaRaMeL abort at %s:%d</span><span class="se">\n</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="n">__FILE__</span><span class="p">,</span>
<span class="w">      </span><span class="n">__LINE__</span><span class="p">,</span>
<span class="w">      </span><span class="s">&quot;unreachable (pattern matches are exhaustive in F*)&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">KRML_HOST_EXIT</span><span class="p">(</span><span class="mi">255U</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="function-monomorphization">
<h3>Function monomorphization<a class="headerlink" href="#function-monomorphization" title="Link to this heading"></a></h3>
<p>As demonstrated above, functions also get monomorphized based on their
instances. Note that using a polymorphic type in an <code class="docutils literal notranslate"><span class="pre">assume</span> <span class="pre">val</span></code> is not
supported.</p>
</section>
<section id="higher-order-with-functions-pointers">
<h3>Higher order with functions pointers<a class="headerlink" href="#higher-order-with-functions-pointers" title="Link to this heading"></a></h3>
<p>Higher order is, to a certain extent, possible (i.e. as long as you don't use
closures). The sample above
demonstrates a block-scope function pointer. The <code class="docutils literal notranslate"><span class="pre">fail_if</span></code> function has
been specialized on <code class="docutils literal notranslate"><span class="pre">K__int32_t_int32_t</span></code>, which is itself a specialization
of the polymorphic pair type of F*. Below is a sample caller of
<code class="docutils literal notranslate"><span class="pre">fail_if__int32_t_int32_t</span></code>, which relies on passing a pair of a function
pointer and its argument.</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="n">abs3</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="nn">Int32</span><span class="p">.</span><span class="n">t</span><span class="o">):</span> <span class="nc">St</span> <span class="nn">Int32</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span>
  <span class="n">fail_if</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">abs2</span><span class="o">)</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int32_t</span><span class="w"> </span><span class="nf">abs3</span><span class="p">(</span><span class="kt">int32_t</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span>
<span class="w">    </span><span class="n">fail_if__int32_t_int32_t</span><span class="p">((</span>
<span class="w">        </span><span class="p">(</span><span class="n">K___int32_t_int32_t____FStar_Pervasives_Native_option__int32_t</span><span class="p">){</span><span class="w"> </span><span class="p">.</span><span class="n">fst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">snd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">abs2</span><span class="w"> </span><span class="p">}</span>
<span class="w">      </span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Local closures are not supported, as they do not have a natural compilation
scheme to C. You can, however, rely on <code class="docutils literal notranslate"><span class="pre">[&#64;inline_let]</span></code> to define local
helpers.</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="n">pow4</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="nn">UInt32</span><span class="p">.</span><span class="n">t</span><span class="o">):</span> <span class="nn">UInt32</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span>
  <span class="kd">let</span> <span class="k">open</span> <span class="nn">FStar</span><span class="p">.</span><span class="nc">UInt32</span> <span class="k">in</span>
  <span class="o">[@</span> <span class="n">inline_let</span> <span class="o">]</span>
  <span class="kd">let</span> <span class="n">pow2</span> <span class="o">(</span><span class="n">y</span><span class="o">:</span> <span class="nn">UInt32</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*%^</span> <span class="n">y</span> <span class="k">in</span>
  <span class="n">pow2</span> <span class="o">(</span><span class="n">pow2</span> <span class="n">x</span><span class="o">)</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">pow4</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">x0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">x0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If this is not workable, you will have to define the closure state
yourself, carry it around, and apply the closure to its environment manually.</p>
</section>
<section id="non-constant-globals">
<h3>Non-constant globals<a class="headerlink" href="#non-constant-globals" title="Link to this heading"></a></h3>
<p>In the case that the user defines a global variable that does not compile to
a C11 constant, KaRaMeL generates a &quot;static initializer&quot; in the special
<code class="docutils literal notranslate"><span class="pre">krmlinit_globals</span></code> function. If the program has a <code class="docutils literal notranslate"><span class="pre">main</span></code>, KaRaMeL
automatically prepends a call to <code class="docutils literal notranslate"><span class="pre">krmlinit_globals</span></code> in the <code class="docutils literal notranslate"><span class="pre">main</span></code>. If
the program does not have a <code class="docutils literal notranslate"><span class="pre">main</span></code> and is intended to be used as a
library, KaRaMeL emits a warning, which is fatal by default.</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="n">uint128_zero</span> <span class="bp">()</span><span class="o">:</span> <span class="nc">Tot</span> <span class="n">uint128</span> <span class="o">=</span>
  <span class="o">{</span> <span class="n">high</span> <span class="o">=</span> <span class="mi">0</span><span class="n">UL</span><span class="o">;</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="n">UL</span> <span class="o">}</span>

<span class="kd">let</span> <span class="n">zero</span> <span class="o">=</span> <span class="n">uint128_zero</span> <span class="bp">()</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>krml<span class="w"> </span>-skip-linking<span class="w"> </span>-no-prefix<span class="w"> </span>LowStar<span class="w"> </span>LowStar.fst
<span class="o">(</span>...<span class="o">)</span>
Warning<span class="w"> </span><span class="m">9</span>:<span class="w"> </span>:<span class="w"> </span>Some<span class="w"> </span>globals<span class="w"> </span>did<span class="w"> </span>not<span class="w"> </span>compile<span class="w"> </span>to<span class="w"> </span>C<span class="w"> </span>values<span class="w"> </span>and<span class="w"> </span>must<span class="w"> </span>be
initialized<span class="w"> </span>before<span class="w"> </span>starting<span class="w"> </span>main<span class="o">()</span>.<span class="w"> </span>You<span class="w"> </span>did<span class="w"> </span>not<span class="w"> </span>provide<span class="w"> </span>a<span class="w"> </span>main<span class="w"> </span><span class="k">function</span>,
so<span class="w"> </span>users<span class="w"> </span>of<span class="w"> </span>your<span class="w"> </span>library<span class="w"> </span>MUST<span class="w"> </span>MAKE<span class="w"> </span>SURE<span class="w"> </span>they<span class="w"> </span>call<span class="w"> </span>krmlinit_globals<span class="o">()</span><span class="p">;</span>
<span class="o">(</span>see<span class="w"> </span>krmlinit.c<span class="o">)</span>.

$<span class="w"> </span>cat<span class="w"> </span>krmlinit.c
<span class="o">(</span>...<span class="o">)</span>
void<span class="w"> </span>krmlinit_globals<span class="o">()</span>
<span class="o">{</span>
<span class="w">  </span><span class="nv">zero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>uint128_zero<span class="o">()</span><span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
</section>
</section>
<section id="code-quality-improvements">
<h2>Code quality improvements<a class="headerlink" href="#code-quality-improvements" title="Link to this heading"></a></h2>
<p>In addition to all the features describe above, KaRaMeL will go great lengths to
generate readable code. Here are some of the optimization passes performed.</p>
<section id="unused-argument-elimination">
<h3>Unused argument elimination<a class="headerlink" href="#unused-argument-elimination" title="Link to this heading"></a></h3>
<p>There are three unused argument elimination passes.</p>
<p><em>Type-based</em> argument elimination removes all unit arguments to functions,
everywhere, always. (This is particularly useful if your functions take
<code class="docutils literal notranslate"><span class="pre">Ghost.erased</span></code> arguments.)</p>
<p><em>Usage-based</em> argument elimination removes unused arguments to functions <em>only</em>
if they are private to the current module and do not appear in the header <em>and</em>
if they are only used in a first-order setting, i.e. always used as the head of
a fully applied function call.</p>
<p><em>Data type</em> argument elimination removes type parameters from types that don't
use them; it also removes unit arguments to constructors, i.e. your C type
declarations should never have a unit field.</p>
</section>
<section id="temporary-variable-elimination">
<h3>Temporary variable elimination<a class="headerlink" href="#temporary-variable-elimination" title="Link to this heading"></a></h3>
<p>F* introduces a significant amount of temporary variables called <code class="docutils literal notranslate"><span class="pre">uu___</span></code>,
owing to its monadic let semantics. (You can see these variables looking at the
generated OCaml code.) KaRaMeL uses two different syntactic criteria to get rid
of those.</p>
</section>
<section id="tuple-elimination">
<h3>Tuple elimination<a class="headerlink" href="#tuple-elimination" title="Link to this heading"></a></h3>
<p>To avoid allocating too many intermediary values of monomorphized tuple types,
KaRaMeL applies the following two rules before data type compilation &amp;
monomorphization:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">i</span><span class="p">)</span>   <span class="n">match</span> <span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="k">with</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">e</span>  <span class="o">~~~&gt;</span>
      <span class="n">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">e1</span> <span class="ow">in</span> <span class="n">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">e2</span> <span class="ow">in</span> <span class="n">e</span>
<span class="p">(</span><span class="n">ii</span><span class="p">)</span>  <span class="n">match</span> <span class="n">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">e0</span> <span class="ow">in</span> <span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="k">with</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">e</span>  <span class="o">~~~&gt;</span>
      <span class="n">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">e0</span> <span class="ow">in</span> <span class="n">match</span> <span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="k">with</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">e</span>
</pre></div>
</div>
<p>This is absolutely crucial to share code between specs and implementations. See
the toy project for an example in action.</p>
</section>
<section id="dead-code-elimination">
<h3>Dead code elimination<a class="headerlink" href="#dead-code-elimination" title="Link to this heading"></a></h3>
<p>Any code that becomes unreachable after bundling (see advanced topics) is
automatically removed.</p>
</section>
<section id="unused-local-variable-elimination">
<h3>Unused local variable elimination<a class="headerlink" href="#unused-local-variable-elimination" title="Link to this heading"></a></h3>
<p>Using a syntactic criterion, local variables that have no observable
side-effects are eliminated.</p>
</section>
<section id="functional-update-optimization">
<h3>Functional update optimization<a class="headerlink" href="#functional-update-optimization" title="Link to this heading"></a></h3>
<p>Code that mutakes a single field of a struct in place compiles to a C mutation.</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="n">b</span><span class="o">.(</span><span class="mi">0</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="o">{</span> <span class="n">b</span><span class="o">.(</span><span class="mi">0</span><span class="o">)</span> <span class="k">with</span> <span class="n">f</span> <span class="o">=</span> <span class="n">e</span> <span class="o">}</span>
</pre></div>
</div>
<p>gives:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">b</span><span class="o">-&gt;</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">;</span>
</pre></div>
</div>
</section>
</section>
<section id="some-non-low-code">
<h2>Some non-Low* code<a class="headerlink" href="#some-non-low-code" title="Link to this heading"></a></h2>
<p>We now review some classic programming patterns that are not supported in
Low*.</p>
<p>The example below cannot be compiled for the following reasons:</p>
<ul class="simple">
<li><p>local recursive let-bindings are not Low*;</p></li>
<li><p>local closure captures variable in scope (KaRaMeL does not do closure conversion)</p></li>
<li><p>the list type is not Low*.</p></li>
</ul>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="n">filter_map</span> <span class="o">#</span><span class="n">a</span> <span class="o">#</span><span class="n">b</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">option</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span><span class="o">:</span> <span class="kt">list</span> <span class="n">a</span><span class="o">):</span> <span class="kt">list</span> <span class="n">b</span> <span class="o">=</span>
  <span class="kd">let</span> <span class="kd">rec</span> <span class="n">aux</span> <span class="o">(</span><span class="n">acc</span><span class="o">:</span> <span class="kt">list</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span><span class="o">:</span> <span class="kt">list</span> <span class="n">a</span><span class="o">):</span> <span class="nc">Tot</span> <span class="o">(</span><span class="kt">list</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">decreases</span> <span class="n">l</span><span class="o">)</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>
        <span class="n">begin</span> <span class="k">match</span> <span class="n">f</span> <span class="n">hd</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nc">Some</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">aux</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">acc</span><span class="o">)</span> <span class="n">tl</span>
        <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">aux</span> <span class="n">acc</span> <span class="n">tl</span>
        <span class="k">end</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span>
        <span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">acc</span>
  <span class="k">in</span>
  <span class="n">aux</span> <span class="bp">[]</span> <span class="n">l</span>
</pre></div>
</div>
<p>Trying to compile the snippet above will generate a warning when calling F*
to generate a <code class="docutils literal notranslate"><span class="pre">.krml</span></code> file.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>krml<span class="w"> </span>-skip-compilation<span class="w"> </span>-verbose<span class="w"> </span>LowStar.fst
⚙<span class="w"> </span>KaRaMeL<span class="w"> </span>auto-detecting<span class="w"> </span>tools.
<span class="o">(</span>...<span class="o">)</span>
✔<span class="w"> </span><span class="o">[</span>F*,extract<span class="o">]</span>
&lt;dummy&gt;<span class="o">(</span><span class="m">0</span>,0-0,0<span class="o">)</span>:<span class="w"> </span><span class="o">(</span>Warning<span class="w"> </span><span class="m">250</span><span class="o">)</span><span class="w"> </span>Error<span class="w"> </span><span class="k">while</span><span class="w"> </span>extracting<span class="w"> </span>LowStar.filter_map
to<span class="w"> </span>KaRaMeL<span class="w"> </span><span class="o">(</span>Failure<span class="o">(</span><span class="s2">&quot;Internal error: name not found aux\n&quot;</span><span class="o">))</span>
</pre></div>
</div>
<p>To explain why the list type cannot be compiled to C, consider the snippet
below. Data types are compiled as flat structures in C, meaning that the
list type would have infinite size in C. This is compiled by KaRaMeL but
rejected by the C compiler. See ?? for an example of a linked list.</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="n">list_int32</span> <span class="o">=</span>
<span class="o">|</span> <span class="nc">Nil</span><span class="o">:</span> <span class="n">list_int32</span>
<span class="o">|</span> <span class="nc">Cons</span><span class="o">:</span> <span class="n">hd</span><span class="o">:</span><span class="nn">Int32</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">tl</span><span class="o">:</span><span class="n">list_int32</span> <span class="o">-&gt;</span> <span class="n">list_int32</span>

<span class="kd">let</span> <span class="n">mk_list</span> <span class="bp">()</span><span class="o">:</span> <span class="nc">St</span> <span class="n">list_int32</span> <span class="o">=</span>
  <span class="nc">Cons</span> <span class="mi">0</span><span class="n">l</span> <span class="nc">Nil</span>
</pre></div>
</div>
<p>Trying to compile the snippet above will generate an error when calling the
C compiler to generate a <code class="docutils literal notranslate"><span class="pre">.o</span></code> file.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>krml<span class="w"> </span>-skip-linking<span class="w"> </span>-verbose<span class="w"> </span>LowStar.fst
⚙<span class="w"> </span>KaRaMeL<span class="w"> </span>auto-detecting<span class="w"> </span>tools.
<span class="o">(</span>...<span class="o">)</span>
✘<span class="w"> </span><span class="o">[</span>CC,./LowStar.c<span class="o">]</span>
In<span class="w"> </span>file<span class="w"> </span>included<span class="w"> </span>from<span class="w"> </span>./LowStar.c:8:0:
./LowStar.h:95:22:<span class="w"> </span>error:<span class="w"> </span>field<span class="w"> </span>‘tl’<span class="w"> </span>has<span class="w"> </span>incomplete<span class="w"> </span><span class="nb">type</span>
<span class="w">   </span>LowStar_list_int32<span class="w"> </span>tl<span class="p">;</span>
</pre></div>
</div>
<p>Polymorphic assumes are also not compiled. KaRaMeL could generate one C
<code class="docutils literal notranslate"><span class="pre">extern</span></code> declaration per monomorphic use, but this would require the user
to provide a substantial amount of manually-written code, so instead we
refuse to compile the definition below.</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="c">// Cannot be compiled: polymorphic assume val; solution: make the function</span>
<span class="c">// monomorphic, or provide a C macro</span>
<span class="ne">assume</span> <span class="k">val</span> <span class="n">pair_up</span><span class="o">:</span> <span class="o">#</span><span class="n">a</span><span class="o">:</span><span class="nc">Type</span> <span class="o">-&gt;</span> <span class="o">#</span><span class="n">b</span><span class="o">:</span><span class="nc">Type</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
</pre></div>
</div>
<p>Trying to compile the snippet above will generate a warning when calling F*
to generate a <code class="docutils literal notranslate"><span class="pre">.krml</span></code> file.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>krml<span class="w"> </span>-skip-compilation<span class="w"> </span>-verbose<span class="w"> </span>LowStar.fst
⚙<span class="w"> </span>KaRaMeL<span class="w"> </span>auto-detecting<span class="w"> </span>tools.
<span class="o">(</span>...<span class="o">)</span>
✔<span class="w"> </span><span class="o">[</span>F*,extract<span class="o">]</span>
Not<span class="w"> </span>extracting<span class="w"> </span>LowStar.pair_up<span class="w"> </span>to<span class="w"> </span>KaRaMeL<span class="w"> </span><span class="o">(</span>polymorphic<span class="w"> </span>assumes<span class="w"> </span>are<span class="w"> </span>not<span class="w"> </span>supported<span class="o">)</span>
</pre></div>
</div>
<p>One point worth mentioning is that indexed types are by default not
supported. See section ?? for an unofficial KaRaMeL extension that works in
some very narrow cases, or rewrite your code to make <code class="docutils literal notranslate"><span class="pre">t</span></code> an inductive. KaRaMeL
currently does not have support for untagged unions, i.e. automatically
making <code class="docutils literal notranslate"><span class="pre">t</span></code> a C union.</p>
<div class="highlight-fstar notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="n">alg</span> <span class="o">=</span> <span class="o">|</span> <span class="nc">Alg1</span> <span class="o">|</span> <span class="nc">Alg2</span>
<span class="kd">let</span> <span class="n">t</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">alg</span><span class="o">)</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">a</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Alg1</span> <span class="o">-&gt;</span> <span class="nn">UInt32</span><span class="p">.</span><span class="n">t</span>
  <span class="o">|</span> <span class="nc">Alg2</span> <span class="o">-&gt;</span> <span class="n">uint128</span>

<span class="kd">let</span> <span class="n">default_t</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">alg</span><span class="o">):</span> <span class="n">t</span> <span class="n">a</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">a</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Alg1</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="n">ul</span>
  <span class="o">|</span> <span class="nc">Alg2</span> <span class="o">-&gt;</span> <span class="n">zero</span>
</pre></div>
</div>
<p>Trying to compile the snippet above will generate invalid C code.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// The void* is the sign that something was not type-able in Low* and was</span>
<span class="c1">// sent to the Top type.</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">default_t</span><span class="p">(</span><span class="n">alg</span><span class="w"> </span><span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">Alg1</span><span class="p">:</span>
<span class="w">      </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="mi">0U</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">Alg2</span><span class="p">:</span>
<span class="w">      </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">zero</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">      </span><span class="p">{</span>
<span class="w">        </span><span class="n">KRML_HOST_PRINTF</span><span class="p">(</span><span class="s">&quot;KaRaMeL incomplete match at %s:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">__FILE__</span><span class="p">,</span><span class="w"> </span><span class="n">__LINE__</span><span class="p">);</span>
<span class="w">        </span><span class="n">KRML_HOST_EXIT</span><span class="p">(</span><span class="mi">253U</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you are lucky, the C compiler may generate an error:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>krml<span class="w"> </span>-skip-linking<span class="w"> </span>LowStar.fst<span class="w"> </span>-add-include<span class="w"> </span><span class="s1">&#39;&quot;krmlstr.h&quot;&#39;</span><span class="w"> </span>-no-prefix<span class="w"> </span>LowStar<span class="w"> </span>-warn-error<span class="w"> </span>+9

✘<span class="w"> </span><span class="o">[</span>CC,./LowStar.c<span class="o">]</span>
./LowStar.c:<span class="w"> </span>In<span class="w"> </span><span class="k">function</span><span class="w"> </span>‘default_t’:
./LowStar.c:291:9:<span class="w"> </span>error:<span class="w"> </span>cannot<span class="w"> </span>convert<span class="w"> </span>to<span class="w"> </span>a<span class="w"> </span>pointer<span class="w"> </span><span class="nb">type</span>
<span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="o">(</span>void<span class="w"> </span>*<span class="o">)</span>zero<span class="p">;</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Setup.html" class="btn btn-neutral float-left" title="Tooling and project setup" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="TocLibraries.html" class="btn btn-neutral float-right" title="Low* libraries" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018, Jonathan Protzenko.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>