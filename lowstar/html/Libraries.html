

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Low* core libraries &mdash; The KreMLin user manual  documentation</title>
  

  
  <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'./',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="static/jquery.js"></script>
        <script type="text/javascript" src="static/underscore.js"></script>
        <script type="text/javascript" src="static/doctools.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Low* buffer libraries" href="BufferLibraries.html" />
    <link rel="prev" title="Low* libraries" href="TocLibraries.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> The KreMLin user manual
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Setup.html">Tooling and project setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="Core.html">Low* language</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="TocLibraries.html">Low* libraries</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Low* core libraries</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-memory-model">The memory model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-f-hyperheap-model">The F* HyperHeap model</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-hyperstack-model">The HyperStack model</a></li>
<li class="toctree-l4"><a class="reference internal" href="#advanced-the-stackinline-effect">Advanced: the <code class="docutils literal notranslate"><span class="pre">StackInline</span></code> effect</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#machine-integers">Machine integers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-buffer-library">The buffer library</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-modifies-clauses-library">The modifies clauses library</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="BufferLibraries.html">Low* buffer libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="MoreLibraries.html">Low* system libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="DataStructures.html">Low* data structure libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="StringManipulation.html">Low* string manipulation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="TocExamples.html">Low* examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="Toy.html">A toy project for learning Low*</a></li>
<li class="toctree-l1"><a class="reference internal" href="AdvancedTips.html">Advanced tips &amp; tricks</a></li>
<li class="toctree-l1"><a class="reference internal" href="AdvancedTopics.html">Advanced KreMLin topics</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">The KreMLin user manual</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="TocLibraries.html">Low* libraries</a> &raquo;</li>
        
      <li>Low* core libraries</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/Libraries.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="low-core-libraries">
<h1>Low* core libraries<a class="headerlink" href="#low-core-libraries" title="Permalink to this headline">¶</a></h1>
<p>Low* is made up of a few primitive libraries that enjoy first-class support in
KreMLin. These core libraries are typically made up of a model (an <code class="docutils literal notranslate"><span class="pre">.fst</span></code>
file) and an interface (an <code class="docutils literal notranslate"><span class="pre">.fsti</span></code> file). Verification is performed against
the model, but at extraction-time, the model is replaced with primitive C
constructs.</p>
<div class="section" id="the-memory-model">
<span id="memory-model"></span><h2>The memory model<a class="headerlink" href="#the-memory-model" title="Permalink to this headline">¶</a></h2>
<p>Beyond the language subset, one defining component of Low* is how it models
the C memory.</p>
<div class="section" id="the-f-hyperheap-model">
<h3>The F* HyperHeap model<a class="headerlink" href="#the-f-hyperheap-model" title="Permalink to this headline">¶</a></h3>
<p>F* is by default equipped with HyperHeap, a hierarchical memory model that
divides the heap into a tree of regions. This coarse-grained separation
allows the programmer to state modifies clauses at the level of regions, rather
than on individual references.</p>
<p>The HyperHeap memory model is described in the <a class="reference external" href="https://www.fstar-lang.org/papers/mumon/">2016 POPL paper</a>, as well as the <a class="reference external" href="https://www.fstar-lang.org/tutorial">F* tutorial</a>. We assume that the reader has a passing
degree of familiarity with HyperHeap.</p>
</div>
<div class="section" id="the-hyperstack-model">
<h3>The HyperStack model<a class="headerlink" href="#the-hyperstack-model" title="Permalink to this headline">¶</a></h3>
<p>Low* refines the HyperHeap memory model, adding a distinguished set of regions
that model the C call stack. Programs may use stack allocation, heap allocation
or both. The HyperStack memory model offers a set of effects that capture the
allocation behavior of functions.</p>
<p>The HyperStack memory model comprises the files
<code class="docutils literal notranslate"><span class="pre">FStar.Monotonic.HyperStack.fst</span></code>, <code class="docutils literal notranslate"><span class="pre">FStar.HyperStack.fst</span></code> and
<code class="docutils literal notranslate"><span class="pre">FStar.HyperStack.ST.fst</span></code> in the <code class="docutils literal notranslate"><span class="pre">ulib</span></code> directory of F*.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Many verification errors point to definitions in these three files. Being
familiar with these modules, their combinators and key concepts helps
understand why a given program fails to verify.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">We recommend always defining the <code class="docutils literal notranslate"><span class="pre">ST</span></code> abbreviation at the beginning of
your module, in order to shadow the <code class="docutils literal notranslate"><span class="pre">FStar.ST</span></code> module, which is not
Low*.</p>
</div>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">ST</span> <span class="o">=</span> <span class="n">FStar</span><span class="o">.</span><span class="n">HyperStack</span><span class="o">.</span><span class="n">ST</span>
<span class="n">module</span> <span class="n">HS</span> <span class="o">=</span> <span class="n">FStar</span><span class="o">.</span><span class="n">HyperStack</span>
</pre></div>
</div>
<p>The top-level region is the root, and is always a valid region. <code class="docutils literal notranslate"><span class="pre">HS.rid</span></code>
is the type of regions.</p>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">root</span><span class="p">:</span> <span class="n">HS</span><span class="o">.</span><span class="n">rid</span> <span class="o">=</span> <span class="n">HS</span><span class="o">.</span><span class="n">roo</span>
</pre></div>
</div>
<p>Stack frames are modeled as distinguished regions that satisfy the
<code class="docutils literal notranslate"><span class="pre">is_stack_region</span></code> predicate. Allocating in a stack frame, unsurprisingly,
results in a stack-allocated variable or array in C. Stack frames may be
de-allocated as program execution progresses up the call stack, meaning that
the underlying HyperHeap region may disappear.</p>
<p>Regions that are not stack frames may <em>not</em> be de-allocated, and therefore
satisfy the <code class="docutils literal notranslate"><span class="pre">is_eternal_region</span></code> predicate. This includes the <code class="docutils literal notranslate"><span class="pre">root</span></code>.
Allocating in one of these regions amounts to performing a heap allocation
in C.</p>
<p>Pushing a new stack frame amount to allocating a new stack region. In the
HyperHeap model, creating a new region requires a <em>parent</em>. Thus, when a
new stack frame is allocated, its parent is either the top-most stack frame,
or the <code class="docutils literal notranslate"><span class="pre">root</span></code> if no stack frame has been allocated so far.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">root</span></code> is not a stack region and does <em>not</em> satisfy <code class="docutils literal notranslate"><span class="pre">is_stack_region</span></code>.</p>
</div>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">_</span> <span class="o">=</span>
  <span class="n">HS</span><span class="o">.</span><span class="n">root_is_not_freeable</span> <span class="p">();</span>
  <span class="k">assert</span> <span class="p">(</span><span class="n">ST</span><span class="o">.</span><span class="n">is_eternal_region</span> <span class="n">root</span> <span class="o">/</span>\ <span class="o">~</span> <span class="p">(</span><span class="n">Monotonic</span><span class="o">.</span><span class="n">HyperStack</span><span class="o">.</span><span class="n">is_stack_region</span> <span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
<p>The most popular effect is the <code class="docutils literal notranslate"><span class="pre">Stack</span></code> effect, which takes:</p>
<ul class="simple">
<li>a precondition over the initial heap, of type <code class="docutils literal notranslate"><span class="pre">HS.mem</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code>, and a</li>
<li>post-condition over the initial heap, the result, the final heap, of type
<code class="docutils literal notranslate"><span class="pre">HS.mem</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">HS.mem</span> <span class="pre">-&gt;</span> <span class="pre">Type</span></code></li>
</ul>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">effect</span> <span class="n">Stack</span> <span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="n">Type</span><span class="p">)</span> <span class="p">(</span><span class="n">pre</span><span class="p">:</span> <span class="n">ST</span><span class="o">.</span><span class="n">st_pre</span><span class="p">)</span> <span class="p">(</span><span class="n">post</span><span class="p">:</span> <span class="p">(</span><span class="n">m0</span><span class="p">:</span> <span class="n">HS</span><span class="o">.</span><span class="n">mem</span> <span class="o">-&gt;</span> <span class="n">Tot</span> <span class="p">(</span><span class="n">ST</span><span class="o">.</span><span class="n">st_post</span><span class="s1">&#39; a (pre m0)))) =</span>
  <span class="n">STATE</span> <span class="n">a</span>
    <span class="p">(</span><span class="n">fun</span> <span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="n">ST</span><span class="o">.</span><span class="n">st_post</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">h</span><span class="p">:</span> <span class="n">HS</span><span class="o">.</span><span class="n">mem</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">pre</span> <span class="n">h</span> <span class="o">/</span>\ <span class="p">(</span><span class="n">forall</span> <span class="n">a</span> <span class="n">h1</span><span class="o">.</span> <span class="p">(</span><span class="n">pre</span> <span class="n">h</span> <span class="o">/</span>\ <span class="n">post</span> <span class="n">h</span> <span class="n">a</span> <span class="n">h1</span> <span class="o">/</span>\ <span class="n">ST</span><span class="o">.</span><span class="n">equal_domains</span> <span class="n">h</span> <span class="n">h1</span><span class="p">)</span> <span class="o">==&gt;</span> <span class="n">p</span> <span class="n">a</span> <span class="n">h1</span><span class="p">))</span>
</pre></div>
</div>
<p>The relevant bit in this otherwise mundane definition is the
<code class="docutils literal notranslate"><span class="pre">ST.equal_domains</span></code> predicate.</p>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">equal_domains</span> <span class="p">(</span><span class="n">m0</span> <span class="n">m1</span><span class="p">:</span> <span class="n">HS</span><span class="o">.</span><span class="n">mem</span><span class="p">)</span> <span class="o">=</span>
  <span class="p">(</span><span class="n">HS</span><span class="o">.</span><span class="n">get_tip</span> <span class="n">m0</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">HS</span><span class="o">.</span><span class="n">get_tip</span> <span class="n">m1</span><span class="p">)</span> <span class="o">/</span>\
  <span class="n">Set</span><span class="o">.</span><span class="n">equal</span> <span class="p">(</span><span class="n">Map</span><span class="o">.</span><span class="n">domain</span> <span class="p">(</span><span class="n">HS</span><span class="o">.</span><span class="n">get_hmap</span> <span class="n">m0</span><span class="p">))</span> <span class="p">(</span><span class="n">Map</span><span class="o">.</span><span class="n">domain</span> <span class="p">(</span><span class="n">HS</span><span class="o">.</span><span class="n">get_hmap</span> <span class="n">m1</span><span class="p">))</span> <span class="o">/</span>\
  <span class="n">ST</span><span class="o">.</span><span class="n">same_refs_in_all_regions</span> <span class="n">m0</span> <span class="n">m1</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">equal_domains</span></code> predicate states that a function in the <code class="docutils literal notranslate"><span class="pre">Stack</span></code> effect:</p>
<ul class="simple">
<li>preserves the <code class="docutils literal notranslate"><span class="pre">tip</span></code> of the memory, i.e. calling this
function leaves the C call stack intact;</li>
<li>does not allocate any new region on the heap, i.e. this is a
C function that does not heap-allocate;</li>
<li>does not allocate in any existing region, i.e. this is a C
function that does not grow any existing stack frame on the call stack.</li>
</ul>
<p>A function that satisfies these conditions is a function that can be safely
compiled as a C function. In other words, using the native C call stack is a
valid implementation of our model.</p>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">UInt32</span><span class="o">.</span><span class="n">t</span><span class="p">):</span> <span class="n">Stack</span> <span class="n">UInt32</span><span class="o">.</span><span class="n">t</span> <span class="p">(</span><span class="n">fun</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="kc">True</span><span class="p">)</span> <span class="p">(</span><span class="n">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="kc">True</span><span class="p">)</span> <span class="o">=</span>
  <span class="n">FStar</span><span class="o">.</span><span class="n">UInt32</span><span class="o">.</span><span class="p">(</span> <span class="n">x</span> <span class="o">*%^</span> <span class="n">x</span> <span class="p">)</span>
</pre></div>
</div>
<p>Based on the knowledge above, consider the following failing function.</p>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">@</span> <span class="n">expect_failure</span> <span class="p">]</span>
<span class="n">let</span> <span class="n">g</span> <span class="p">():</span> <span class="n">Stack</span> <span class="n">unit</span> <span class="p">(</span><span class="n">fun</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="kc">True</span><span class="p">)</span> <span class="p">(</span><span class="n">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="kc">True</span><span class="p">)</span> <span class="o">=</span>
  <span class="n">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">alloca</span> <span class="mi">0</span><span class="n">ul</span> <span class="mi">8</span><span class="n">ul</span> <span class="ow">in</span>
  <span class="p">()</span>
</pre></div>
</div>
<p>F* reports an assertion failure for the <code class="docutils literal notranslate"><span class="pre">is_stack_region</span></code> predicate.
Indeed, the <code class="docutils literal notranslate"><span class="pre">alloca</span></code> function requires that the <code class="docutils literal notranslate"><span class="pre">tip</span></code> be a valid stack
region, which is false when no stack frame has been pushed on the call stack.</p>
<p>One important insight at this stage is that F* does not “automatically”
enrich the verification context with the assumption that upon entering
<code class="docutils literal notranslate"><span class="pre">g</span></code>, we have pushed a new stack frame. This would be the wrong thing to do
for a total function; furthermore, there is simply no such support in the language.</p>
<p>Rather, the user is expected to manually indicate which operations need to
conceptually happen in a new stack frame. The Low* memory model provides two
combinators for this purpose: <code class="docutils literal notranslate"><span class="pre">push_frame</span></code> and <code class="docutils literal notranslate"><span class="pre">pop_frame</span></code>. The <code class="docutils literal notranslate"><span class="pre">f</span></code>
function did not need them, because it performed no stateful operation.</p>
<p>We can attempt to fix <code class="docutils literal notranslate"><span class="pre">g</span></code> by adding a call to <code class="docutils literal notranslate"><span class="pre">push_frame</span></code>.</p>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">@</span> <span class="n">expect_failure</span> <span class="p">]</span>
<span class="n">let</span> <span class="n">g2</span> <span class="p">():</span> <span class="n">Stack</span> <span class="n">unit</span> <span class="p">(</span><span class="n">fun</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="kc">True</span><span class="p">)</span> <span class="p">(</span><span class="n">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="kc">True</span><span class="p">)</span> <span class="o">=</span>
  <span class="n">push_frame</span> <span class="p">();</span>
  <span class="n">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">alloca</span> <span class="mi">0</span><span class="n">ul</span> <span class="mi">8</span><span class="n">ul</span> <span class="ow">in</span>
  <span class="p">()</span>
</pre></div>
</div>
<p>F* now reports an error for the <code class="docutils literal notranslate"><span class="pre">equal_domains</span></code> predicate above. Indeed,
the only way to leave the C call stack intact, and therefore satisfy the
requirements of the <code class="docutils literal notranslate"><span class="pre">Stack</span></code> effect, is to ensure we pop the stack
frame we just pushed.</p>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">g3</span> <span class="p">():</span> <span class="n">Stack</span> <span class="n">unit</span> <span class="p">(</span><span class="n">fun</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="kc">True</span><span class="p">)</span> <span class="p">(</span><span class="n">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="kc">True</span><span class="p">)</span> <span class="o">=</span>
  <span class="n">push_frame</span> <span class="p">();</span>
  <span class="n">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">alloca</span> <span class="mi">0</span><span class="n">ul</span> <span class="mi">8</span><span class="n">ul</span> <span class="ow">in</span>
  <span class="n">pop_frame</span> <span class="p">();</span>
  <span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">g3</span></code> now successfully compiles to C:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">g3</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">uint32_t</span> <span class="n">b</span><span class="p">[</span><span class="mi">8</span><span class="n">U</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="n">U</span> <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Stack</span></code> effect prevents heap allocation, hence ensuring that from the
caller’s perspective, any heap (“eternal”) regions remain unchanged.</p>
<p>For code that performs heap allocations, the libraries offer the <code class="docutils literal notranslate"><span class="pre">ST</span></code>
effect. It is similar to the <code class="docutils literal notranslate"><span class="pre">Stack</span></code> effect, and takes the same form of
pre- and post-conditions, but allows heap allocation.</p>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">g4</span> <span class="p">():</span> <span class="n">ST</span> <span class="n">unit</span> <span class="p">(</span><span class="n">fun</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="kc">True</span><span class="p">)</span> <span class="p">(</span><span class="n">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="kc">True</span><span class="p">)</span> <span class="o">=</span>
  <span class="n">push_frame</span> <span class="p">();</span>
  <span class="n">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">malloc</span> <span class="n">HS</span><span class="o">.</span><span class="n">root</span> <span class="mi">0</span><span class="n">ul</span> <span class="mi">8</span><span class="n">ul</span> <span class="ow">in</span>
  <span class="n">pop_frame</span> <span class="p">();</span>
  <span class="p">()</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">St</span></code> effect might occasionally be convenient.</p>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">effect</span> <span class="n">St</span> <span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="n">Type</span><span class="p">)</span> <span class="o">=</span> <span class="n">ST</span> <span class="n">a</span> <span class="p">(</span><span class="n">fun</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="kc">True</span><span class="p">)</span> <span class="p">(</span><span class="n">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>One can reflect the memory as an <code class="docutils literal notranslate"><span class="pre">HS.mem</span></code> at any program point, by using
<code class="docutils literal notranslate"><span class="pre">ST.get</span> <span class="pre">()</span></code>.</p>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">test_st_get</span> <span class="p">():</span> <span class="n">St</span> <span class="n">unit</span> <span class="o">=</span>
  <span class="n">push_frame</span> <span class="p">();</span>
  <span class="n">let</span> <span class="n">m</span> <span class="o">=</span> <span class="n">ST</span><span class="o">.</span><span class="n">get</span> <span class="p">()</span> <span class="ow">in</span>
  <span class="k">assert</span> <span class="p">(</span><span class="n">Monotonic</span><span class="o">.</span><span class="n">HyperStack</span><span class="o">.</span><span class="n">is_stack_region</span> <span class="p">(</span><span class="n">HS</span><span class="o">.</span><span class="n">get_tip</span> <span class="n">m</span><span class="p">));</span>
  <span class="n">pop_frame</span> <span class="p">()</span>
</pre></div>
</div>
<p>These are the basic building blocks of our memory model. Verifying on top of
this memory model involves reflecting the state of the memory at the proof
level, using the <code class="docutils literal notranslate"><span class="pre">HS.mem</span></code> type, and capturing the effect of allocations,
updates and de-allocations using suitable pre- and post-conditions. This can
be done using a combination of modifies clauses and libraries that reflect
low-level constructs, such as buffers and machine integers, at the proof
level. All of these are covered in the rest of this chapter.</p>
</div>
<div class="section" id="advanced-the-stackinline-effect">
<h3>Advanced: the <code class="docutils literal notranslate"><span class="pre">StackInline</span></code> effect<a class="headerlink" href="#advanced-the-stackinline-effect" title="Permalink to this headline">¶</a></h3>
<p>TODO</p>
</div>
</div>
<div class="section" id="machine-integers">
<span id="id1"></span><h2>Machine integers<a class="headerlink" href="#machine-integers" title="Permalink to this headline">¶</a></h2>
<p>Machine integers are modeled as natural numbers that fit within a certain number
of bits. This model is dropped by KreMLin, in favor of C’s fixed-width types.</p>
<p>Fixed-width integers are found in <code class="docutils literal notranslate"><span class="pre">FStar.UInt{16,32,64,128}.fst</span></code> and
<code class="docutils literal notranslate"><span class="pre">FStar.Int{16,32,64,128}</span></code>. The <code class="docutils literal notranslate"><span class="pre">FStar.Int.Cast.Full.fst</span></code> module offers
conversion functions between these integer types.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">By default, KreMLin relies on the non-standard <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">__int128</span></code> C
type to implement <code class="docutils literal notranslate"><span class="pre">FStar.UInt128.t</span></code>. This type is widely supported
across GCC and Clang versions, but not by the Microsoft compilers. If you
need 128-bit unsigned integers, consider reading
<code class="docutils literal notranslate"><span class="pre">kremlib/README.md</span></code>, which offers both an MSVC-specific alternative,
and a portable, albeit slower, implementation.</p>
</div>
<p>Machine integers offer the classic set of arithmetic operations. Like in C,
unsigned integers have wraparound overflow semantics, exposed via the
<code class="docutils literal notranslate"><span class="pre">add_mod</span></code> function. Signed integers offer no such function. Other
undefined behaviors of C are ruled out at the F* level, such as shifting an
integer by the bit width.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In addition to classic arithmetic operations, some modules offer
constant-time operations such as <code class="docutils literal notranslate"><span class="pre">eq_mask</span></code> and <code class="docutils literal notranslate"><span class="pre">gte_mask</span></code>, which
allow defining a “secret integer” module on top of these integers, that
offers no comparison operator returning a boolean, to avoid timing leaks. See
the HACL* libraries for secret integers.</p>
</div>
<p>Machine integers modules also define operators, suffixed with <code class="docutils literal notranslate"><span class="pre">^</span></code>. For
instance, the <code class="docutils literal notranslate"><span class="pre">+</span></code> operation for <code class="docutils literal notranslate"><span class="pre">UInt32</span></code> is <code class="docutils literal notranslate"><span class="pre">+^</span></code>. Wraparound variants
have an extra <code class="docutils literal notranslate"><span class="pre">%</span></code> character, such as <code class="docutils literal notranslate"><span class="pre">+%^</span></code>, when available.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The unary minus is broken for machine integers.
This does not parse: <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">UInt32.(-^</span> <span class="pre">0ul)</span></code></p>
</div>
<p>Operators follow the standard precedence rules of F*, which are outlined on
its <a class="reference external" href="https://github.com/FStarLang/FStar/wiki/Parsing-and-operator-precedence">wiki</a>.
Operators are resolved in the current scope; we recommend the use of module
abbreviations and the let-open notation <code class="docutils literal notranslate"><span class="pre">M.(</span> <span class="pre">...</span> <span class="pre">)</span></code>.</p>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">U32</span> <span class="o">=</span> <span class="n">FStar</span><span class="o">.</span><span class="n">UInt32</span>

<span class="n">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">U32</span><span class="o">.</span><span class="p">(</span><span class="mi">16</span><span class="n">ul</span> <span class="o">-^</span> <span class="mi">8</span><span class="n">ul</span> <span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">By default, operations require that the caller prove that the result fits in
the given integer width. For instance, <code class="docutils literal notranslate"><span class="pre">U32.add</span></code> has <code class="docutils literal notranslate"><span class="pre">(requires</span> <span class="pre">(size</span> <span class="pre">(v</span>
<span class="pre">a</span> <span class="pre">+</span> <span class="pre">v</span> <span class="pre">b)</span> <span class="pre">n))</span></code> as a precondition. Look at <code class="docutils literal notranslate"><span class="pre">U32.add_modulo</span></code> for no
precondition.</p>
</div>
<p>Machine integers can be reflected as natural numbers of type <code class="docutils literal notranslate"><span class="pre">nat</span></code> using
the <code class="docutils literal notranslate"><span class="pre">v</span></code> function. It is generally more convenient to perform proofs on
natural numbers.</p>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">test_v</span> <span class="p">():</span> <span class="n">unit</span> <span class="o">=</span>
  <span class="n">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="n">ul</span> <span class="ow">in</span>
  <span class="k">assert</span> <span class="p">(</span><span class="n">U32</span><span class="o">.</span><span class="n">v</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="the-buffer-library">
<span id="buffer-library"></span><h2>The buffer library<a class="headerlink" href="#the-buffer-library" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">LowStar.Buffer</span></code> is the workhorse of Low*, and allows modeling C arrays on
the stack and in the heap. <code class="docutils literal notranslate"><span class="pre">LowStar.Buffer</span></code> models C arrays as follows:</p>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">lseq</span> <span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">nat</span><span class="p">)</span> <span class="p">:</span> <span class="n">Type</span> <span class="o">=</span>
  <span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">Seq</span><span class="o">.</span><span class="n">seq</span> <span class="n">a</span> <span class="p">{</span> <span class="n">Seq</span><span class="o">.</span><span class="n">length</span> <span class="n">s</span> <span class="o">==</span> <span class="n">l</span> <span class="p">}</span> <span class="p">)</span>

<span class="n">noeq</span>
<span class="nb">type</span> <span class="n">buffer</span> <span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="n">Type</span><span class="p">)</span> <span class="o">=</span>
  <span class="o">|</span> <span class="n">MkBuffer</span><span class="p">:</span> <span class="n">max_length</span><span class="p">:</span><span class="n">UInt32</span><span class="o">.</span><span class="n">t</span>
    <span class="o">-&gt;</span> <span class="n">content</span><span class="p">:</span><span class="n">reference</span> <span class="p">(</span><span class="n">lseq</span> <span class="n">a</span> <span class="p">(</span><span class="n">U32</span><span class="o">.</span><span class="n">v</span> <span class="n">max_length</span><span class="p">))</span>
    <span class="o">-&gt;</span> <span class="n">idx</span><span class="p">:</span><span class="n">UInt32</span><span class="o">.</span><span class="n">t</span>
    <span class="o">-&gt;</span> <span class="n">length</span><span class="p">:</span><span class="n">UInt32</span><span class="o">.</span><span class="n">t</span><span class="p">{</span><span class="n">U32</span><span class="o">.</span><span class="p">(</span><span class="n">v</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">v</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="n">v</span> <span class="n">max_length</span><span class="p">)}</span>
    <span class="o">-&gt;</span> <span class="n">buffer</span> <span class="n">a</span>
</pre></div>
</div>
<p>In other words, buffers are modeled as a reference to a sequence, along with
a starting index <code class="docutils literal notranslate"><span class="pre">idx</span></code>, and a <code class="docutils literal notranslate"><span class="pre">length</span></code>, which captures how much of an
allocation slice one is currently pointing to.</p>
<p>This is a model: at compilation-time, KreMLin implements buffers using C arrays.</p>
<p><strong>The length</strong> is available in ghost (proof) code only: just like in C, one
cannot compute the length of a buffer at run-time. Therefore, a typical
pattern is to use refinements to tie together a buffer and its length, as we
saw with the initial <code class="docutils literal notranslate"><span class="pre">memcpy</span></code> example.</p>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">do_something</span> <span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">B</span><span class="o">.</span><span class="n">buffer</span> <span class="n">UInt64</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">U32</span><span class="o">.</span><span class="n">t</span> <span class="p">{</span> <span class="n">U32</span><span class="o">.</span><span class="n">v</span> <span class="n">l</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">length</span> <span class="n">x</span> <span class="p">}):</span> <span class="n">St</span> <span class="n">unit</span> <span class="o">=</span>
  <span class="p">()</span>
</pre></div>
</div>
<p><strong>Allocating a buffer on the stack</strong> is done using the <code class="docutils literal notranslate"><span class="pre">alloca</span></code> function,
which takes an initial value and a length. <code class="docutils literal notranslate"><span class="pre">alloca</span></code> requires that the top
of the stack be a valid stack frame.</p>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">test_alloc_stack</span> <span class="p">():</span> <span class="n">Stack</span> <span class="n">unit</span> <span class="p">(</span><span class="n">fun</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="kc">True</span><span class="p">)</span> <span class="p">(</span><span class="n">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="kc">True</span><span class="p">)</span> <span class="o">=</span>
  <span class="n">push_frame</span> <span class="p">();</span>
  <span class="n">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">alloca</span> <span class="mi">0</span><span class="n">UL</span> <span class="mi">8</span><span class="n">ul</span> <span class="ow">in</span>
  <span class="n">pop_frame</span> <span class="p">();</span>
  <span class="p">()</span>
</pre></div>
</div>
<p><strong>Allocating a buffer on the heap</strong> is done using the <code class="docutils literal notranslate"><span class="pre">malloc</span></code> function,
which takes a region, an initial value and a length. The region is purely
for proof and separation purposes, and has no effect on the generated code. A
buffer created with <code class="docutils literal notranslate"><span class="pre">malloc</span></code> can be freed with <code class="docutils literal notranslate"><span class="pre">free</span></code>.</p>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">test_alloc</span> <span class="p">():</span> <span class="n">St</span> <span class="n">unit</span> <span class="o">=</span>
  <span class="n">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">malloc</span> <span class="n">HS</span><span class="o">.</span><span class="n">root</span> <span class="mi">0</span><span class="n">UL</span> <span class="mi">8</span><span class="n">ul</span> <span class="ow">in</span>
  <span class="n">B</span><span class="o">.</span><span class="n">free</span> <span class="n">b</span>
</pre></div>
</div>
<p><strong>Pointer arithmetic</strong> is performed by the means of the <code class="docutils literal notranslate"><span class="pre">sub</span></code> function. Under
the hood, the <code class="docutils literal notranslate"><span class="pre">sub</span></code> function returns a buffer that points to the same
underlying reference, but has different <code class="docutils literal notranslate"><span class="pre">idx</span></code> and <code class="docutils literal notranslate"><span class="pre">length</span></code> fields.</p>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">test_sub</span> <span class="p">():</span> <span class="n">St</span> <span class="n">unit</span> <span class="o">=</span>
  <span class="n">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">malloc</span> <span class="n">HS</span><span class="o">.</span><span class="n">root</span> <span class="mi">0</span><span class="n">UL</span> <span class="mi">8</span><span class="n">ul</span> <span class="ow">in</span>
  <span class="n">let</span> <span class="n">b_l</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">sub</span> <span class="n">b</span> <span class="mi">0</span><span class="n">ul</span> <span class="mi">4</span><span class="n">ul</span> <span class="ow">in</span> <span class="o">//</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">4</span>
  <span class="n">let</span> <span class="n">b_r</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">sub</span> <span class="n">b</span> <span class="mi">4</span><span class="n">ul</span> <span class="mi">4</span><span class="n">ul</span> <span class="ow">in</span> <span class="o">//</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">4</span>
  <span class="n">B</span><span class="o">.</span><span class="n">free</span> <span class="n">b</span>
</pre></div>
</div>
<p>Just like in C, one can only free the base pointer, i.e. this is an error:</p>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">@</span> <span class="n">expect_failure</span> <span class="p">]</span>
<span class="n">let</span> <span class="n">test_sub_error</span> <span class="p">():</span> <span class="n">St</span> <span class="n">unit</span> <span class="o">=</span>
  <span class="n">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">malloc</span> <span class="n">HS</span><span class="o">.</span><span class="n">root</span> <span class="mi">0</span><span class="n">UL</span> <span class="mi">8</span><span class="n">ul</span> <span class="ow">in</span>
  <span class="n">let</span> <span class="n">b_l</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">sub</span> <span class="n">b</span> <span class="mi">0</span><span class="n">ul</span> <span class="mi">4</span><span class="n">ul</span> <span class="ow">in</span> <span class="o">//</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">4</span>
  <span class="n">B</span><span class="o">.</span><span class="n">free</span> <span class="n">b_l</span>
</pre></div>
</div>
<p><strong>Reading and modifying</strong> a buffer is performed by means of the <code class="docutils literal notranslate"><span class="pre">index</span></code>
and <code class="docutils literal notranslate"><span class="pre">upd</span></code> functions. These are exposed as the <code class="docutils literal notranslate"><span class="pre">.()</span></code> and <code class="docutils literal notranslate"><span class="pre">.()&lt;-</span></code>
operators respectively, defined in <code class="docutils literal notranslate"><span class="pre">LowStar.BufferOps</span></code>. This latter module
module only contains those operators, and is meant to be used with
<code class="docutils literal notranslate"><span class="pre">open</span></code> to bring operators into scope without further polluting the
context with any definition from <code class="docutils literal notranslate"><span class="pre">LowStar.Buffer</span></code>.</p>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">test_index</span> <span class="p">():</span> <span class="n">St</span> <span class="n">unit</span> <span class="o">=</span>
  <span class="n">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">malloc</span> <span class="n">HS</span><span class="o">.</span><span class="n">root</span> <span class="mi">0</span><span class="n">UL</span> <span class="mi">8</span><span class="n">ul</span> <span class="ow">in</span>
  <span class="n">b</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="n">ul</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">UInt64</span><span class="o">.</span><span class="n">add_mod</span> <span class="n">b</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="n">ul</span><span class="p">)</span> <span class="n">b</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="n">ul</span><span class="p">);</span>
  <span class="n">B</span><span class="o">.</span><span class="n">free</span> <span class="n">b</span>
</pre></div>
</div>
<p>Buffers are reflected at the proof level using sequences, via the <code class="docutils literal notranslate"><span class="pre">as_seq</span></code>
function, which returns the contents of a given buffer in a given heap, i.e.
a sequence slice ranging over the interval <code class="docutils literal notranslate"><span class="pre">[idx;</span> <span class="pre">idx</span> <span class="pre">+</span> <span class="pre">length)</span></code>.</p>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">test_as_seq</span> <span class="p">():</span> <span class="n">St</span> <span class="n">unit</span> <span class="o">=</span>
  <span class="n">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">malloc</span> <span class="n">HS</span><span class="o">.</span><span class="n">root</span> <span class="mi">0</span><span class="n">UL</span> <span class="mi">1</span><span class="n">ul</span> <span class="ow">in</span>
  <span class="n">let</span> <span class="n">h</span> <span class="o">=</span> <span class="n">ST</span><span class="o">.</span><span class="n">get</span> <span class="p">()</span> <span class="ow">in</span>
  <span class="k">assert</span> <span class="p">(</span><span class="n">Seq</span><span class="o">.</span><span class="n">equal</span> <span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">as_seq</span> <span class="n">h</span> <span class="n">b</span><span class="p">)</span> <span class="p">(</span><span class="n">Seq</span><span class="o">.</span><span class="n">cons</span> <span class="mi">0</span><span class="n">UL</span> <span class="n">Seq</span><span class="o">.</span><span class="n">createEmpty</span><span class="p">));</span>
  <span class="n">B</span><span class="o">.</span><span class="n">free</span> <span class="n">b</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">B.get</span></code> is an often-convenient shorthand to index the value of a
given buffer in a given heap.</p>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">test_get</span> <span class="p">():</span> <span class="n">St</span> <span class="n">unit</span> <span class="o">=</span>
  <span class="n">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">malloc</span> <span class="n">HS</span><span class="o">.</span><span class="n">root</span> <span class="mi">0</span><span class="n">UL</span> <span class="mi">1</span><span class="n">ul</span> <span class="ow">in</span>
  <span class="n">let</span> <span class="n">h</span> <span class="o">=</span> <span class="n">ST</span><span class="o">.</span><span class="n">get</span> <span class="p">()</span> <span class="ow">in</span>
  <span class="k">assert</span> <span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">get</span> <span class="n">h</span> <span class="n">b</span> <span class="mi">0</span> <span class="o">=</span> <span class="mi">0</span><span class="n">UL</span><span class="p">);</span>
  <span class="n">B</span><span class="o">.</span><span class="n">free</span> <span class="n">b</span>
</pre></div>
</div>
<p><strong>C NULL pointers</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">LowStar.Buffer</span></code> also exposes a model of the C NULL pointer, <code class="docutils literal notranslate"><span class="pre">null</span></code> –
this is what you should use if you need zero-length buffers. The NULL
pointer is always live, and always has length 0. The <code class="docutils literal notranslate"><span class="pre">pointer</span></code> and
<code class="docutils literal notranslate"><span class="pre">pointer_or_null</span></code> functions define convenient aliases, while the <code class="docutils literal notranslate"><span class="pre">(!*)</span></code>
operator (defined in <code class="docutils literal notranslate"><span class="pre">LowStar.BufferOps</span></code>) guarantees that the dereference
will be pretty-printed with a <code class="docutils literal notranslate"><span class="pre">*</span></code> C dereference, as opposed to an access
at array index 0. Pointers can always be tested for nullity via the
<code class="docutils literal notranslate"><span class="pre">is_null</span> <span class="pre">p</span></code> function, which is guaranteed to be pretty-printed as <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">!=</span>
<span class="pre">NULL</span></code>.</p>
</div>
<div class="section" id="the-modifies-clauses-library">
<span id="modifies-library"></span><h2>The modifies clauses library<a class="headerlink" href="#the-modifies-clauses-library" title="Permalink to this headline">¶</a></h2>
<p>The current heap model of F* is based on a select-update theory: the heap is
reflected as a map, allocation adds a key in the map, assignment updates the
map, and reading selects from the map.</p>
<p>Proving properties of programs therefore requires the programmer to reason about
the heap model. However, stating precise post-conditions that refer to a
particular heap after a particular update does not scale up to large programs:
we want to reason <em>abstractly</em> about modifications, and use a library of
<em>composable</em> predicates that allow one to <em>generically</em> reason about a given
modification to the heap.</p>
<p>This is where the <code class="docutils literal notranslate"><span class="pre">LowStar.Modifies</span></code> library comes in handy. The modifies
clauses library allows one to reason about allocation, de-allocation,
modifications using a single unified <code class="docutils literal notranslate"><span class="pre">modifies</span></code> clause. An abstract notion of
a memory location allows composing predicates, and deriving properties such as:
“if I modify a location <code class="docutils literal notranslate"><span class="pre">l1</span></code> disjoint from <code class="docutils literal notranslate"><span class="pre">l2</span></code>, then the contents of the
memory at address <code class="docutils literal notranslate"><span class="pre">l2</span></code> remain unchanged”.</p>
<p><strong>Abstract memory locations</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">LowStar.Modifies</span></code> library abstracts over memory locations. Memory
locations have type <code class="docutils literal notranslate"><span class="pre">loc</span></code>. Locations form a monoid, where <code class="docutils literal notranslate"><span class="pre">loc_none</span></code> is
the empty location and <code class="docutils literal notranslate"><span class="pre">loc_union</span></code> combines two location to form the union of
the two.</p>
<p>Several injections exist to create locations; for now, we will mostly use
<code class="docutils literal notranslate"><span class="pre">loc_buffer</span></code>, which injects a <code class="docutils literal notranslate"><span class="pre">LowStar.Buffer.t</span></code> into an abstract location.</p>
<p><strong>Inclusion and disjointness</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">LowStar.Modifies</span></code> module provides an inclusion relation, via
<code class="docutils literal notranslate"><span class="pre">loc_includes</span></code>. This allows the programmer to state, for instance, that the
location of a stack-allocated buffer is included in its stack frame.</p>
<p>Perhaps more useful is the <code class="docutils literal notranslate"><span class="pre">loc_disjoint</span></code> predicates, which allows the
programmer to state that two memory locations do not overlap.</p>
<p><strong>The modifies clause</strong></p>
<p>The modifies clause is of the form <code class="docutils literal notranslate"><span class="pre">modifies</span> <span class="pre">l</span> <span class="pre">h0</span> <span class="pre">h1</span></code> where <code class="docutils literal notranslate"><span class="pre">l</span></code> is an
abstract memory location, <code class="docutils literal notranslate"><span class="pre">h0</span></code> is the initial heap and <code class="docutils literal notranslate"><span class="pre">h1</span></code> is the
resulting heap. Here is an example:</p>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">M</span> <span class="o">=</span> <span class="n">LowStar</span><span class="o">.</span><span class="n">Modifies</span>

<span class="n">let</span> <span class="n">example_modifies_callee</span> <span class="p">(</span><span class="n">b1</span> <span class="n">b2</span><span class="p">:</span> <span class="n">B</span><span class="o">.</span><span class="n">buffer</span> <span class="n">UInt32</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="p">:</span> <span class="n">Stack</span> <span class="n">unit</span>
  <span class="p">(</span><span class="n">requires</span> <span class="p">(</span><span class="n">fun</span> <span class="n">h</span> <span class="o">-&gt;</span> <span class="n">B</span><span class="o">.</span><span class="n">live</span> <span class="n">h</span> <span class="n">b1</span> <span class="o">/</span>\ <span class="n">B</span><span class="o">.</span><span class="n">live</span> <span class="n">h</span> <span class="n">b2</span> <span class="o">/</span>\ <span class="n">B</span><span class="o">.</span><span class="n">length</span> <span class="n">b1</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">/</span>\ <span class="n">B</span><span class="o">.</span><span class="n">length</span> <span class="n">b2</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">/</span>\ <span class="n">B</span><span class="o">.</span><span class="n">disjoint</span> <span class="n">b1</span> <span class="n">b2</span><span class="p">))</span>
  <span class="p">(</span><span class="n">ensures</span> <span class="p">(</span><span class="n">fun</span> <span class="n">h</span> <span class="n">_</span> <span class="n">h</span><span class="s1">&#39; -&gt;</span>
    <span class="n">M</span><span class="o">.</span><span class="n">modifies</span> <span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">loc_union</span> <span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">loc_buffer</span> <span class="n">b1</span><span class="p">)</span> <span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">loc_buffer</span> <span class="n">b2</span><span class="p">))</span> <span class="n">h</span> <span class="n">h</span><span class="s1">&#39; /</span><span class="se">\</span>
<span class="s1">    B.live h&#39;</span> <span class="n">b1</span> <span class="o">/</span>\ <span class="n">B</span><span class="o">.</span><span class="n">live</span> <span class="n">h</span><span class="s1">&#39; b2 /</span><span class="se">\</span>
<span class="s1">    B.get h&#39;</span> <span class="n">b1</span> <span class="mi">0</span> <span class="o">==</span> <span class="mi">18</span><span class="n">ul</span> <span class="o">/</span>\ <span class="n">B</span><span class="o">.</span><span class="n">get</span> <span class="n">h</span><span class="s1">&#39; b2 0 == 42ul</span>
  <span class="p">))</span>
<span class="o">=</span> <span class="n">b2</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="n">ul</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="mi">42</span><span class="n">ul</span><span class="p">;</span>
  <span class="n">b1</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="n">ul</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="mi">18</span><span class="n">ul</span>
</pre></div>
</div>
<p>The pre- and post-conditions of the <code class="docutils literal notranslate"><span class="pre">example_modifies_callee</span></code>
function state that, if <code class="docutils literal notranslate"><span class="pre">b1</span></code> and <code class="docutils literal notranslate"><span class="pre">b2</span></code> are two disjoint live
buffers of length 1, then <code class="docutils literal notranslate"><span class="pre">example_modifies</span></code> changes their
contents to 18ul and 42ul, respectively. In itself, the modifies
clause tells nothing, but it starts becoming useful when the
<code class="docutils literal notranslate"><span class="pre">example_modifies_callee</span></code> function is called by another
function:</p>
<div class="code fstar highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">example_modifies_caller</span> <span class="p">(</span><span class="n">b0</span><span class="p">:</span> <span class="n">B</span><span class="o">.</span><span class="n">buffer</span> <span class="n">UInt32</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="p">:</span> <span class="n">Stack</span> <span class="n">unit</span>
  <span class="p">(</span><span class="n">requires</span> <span class="p">(</span><span class="n">fun</span> <span class="n">h</span> <span class="o">-&gt;</span> <span class="n">B</span><span class="o">.</span><span class="n">live</span> <span class="n">h</span> <span class="n">b0</span> <span class="o">/</span>\ <span class="n">B</span><span class="o">.</span><span class="n">length</span> <span class="n">b0</span> <span class="o">==</span> <span class="mi">3</span><span class="p">))</span>
  <span class="p">(</span><span class="n">ensures</span> <span class="p">(</span><span class="n">fun</span> <span class="n">h</span> <span class="n">_</span> <span class="n">h</span><span class="s1">&#39; -&gt;</span>
    <span class="n">M</span><span class="o">.</span><span class="n">modifies</span> <span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">loc_buffer</span> <span class="n">b0</span><span class="p">)</span> <span class="n">h</span> <span class="n">h</span><span class="s1">&#39; /</span><span class="se">\</span>
<span class="s1">    B.live h&#39;</span> <span class="n">b0</span> <span class="o">/</span>\
    <span class="n">B</span><span class="o">.</span><span class="n">get</span> <span class="n">h</span><span class="s1">&#39; b0 0 == B.get h b0 0</span>
  <span class="p">))</span>
<span class="o">=</span> <span class="n">let</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">sub</span> <span class="n">b0</span> <span class="mi">1</span><span class="n">ul</span> <span class="mi">1</span><span class="n">ul</span> <span class="ow">in</span>
  <span class="n">let</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">sub</span> <span class="n">b0</span> <span class="mi">2</span><span class="n">ul</span> <span class="mi">1</span><span class="n">ul</span> <span class="ow">in</span>
  <span class="n">example_modifies_callee</span> <span class="n">b1</span> <span class="n">b2</span><span class="p">;</span>
  <span class="k">assert</span> <span class="p">(</span><span class="n">forall</span> <span class="n">h</span> <span class="o">.</span> <span class="n">B</span><span class="o">.</span><span class="n">get</span> <span class="n">h</span> <span class="n">b0</span> <span class="mi">0</span> <span class="o">==</span> <span class="n">B</span><span class="o">.</span><span class="n">get</span> <span class="n">h</span> <span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">gsub</span> <span class="n">b0</span> <span class="mi">0</span><span class="n">ul</span> <span class="mi">1</span><span class="n">ul</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>This function takes a buffer <code class="docutils literal notranslate"><span class="pre">b0</span></code> of length 3, and from it,
extracts two disjoint buffers, <code class="docutils literal notranslate"><span class="pre">b1</span></code> and <code class="docutils literal notranslate"><span class="pre">b2</span></code>, as the
sub-buffers of <code class="docutils literal notranslate"><span class="pre">b0</span></code> of length 1 at offsets 1 and 2,
respectively. Since they are both live and disjoint, they can then
be passed to <code class="docutils literal notranslate"><span class="pre">example_modifies_callee</span></code>. Then, the post-condition
of <code class="docutils literal notranslate"><span class="pre">example_modifies_caller</span></code> about the contents of the cell of
<code class="docutils literal notranslate"><span class="pre">b0</span></code> at offset 0 is due to the fact that that cell of <code class="docutils literal notranslate"><span class="pre">b0</span></code> is
disjoint from both <code class="docutils literal notranslate"><span class="pre">b1</span></code> and <code class="docutils literal notranslate"><span class="pre">b2</span></code> (because it is the cell of
the sub-buffer of <code class="docutils literal notranslate"><span class="pre">b0</span></code> at offset 0, as suggested by the
<code class="docutils literal notranslate"><span class="pre">assert</span></code>), and so, by virtue of the <code class="docutils literal notranslate"><span class="pre">modifies</span></code> clause of
<code class="docutils literal notranslate"><span class="pre">example_modifies_callee</span></code>, its value is preserved.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="BufferLibraries.html" class="btn btn-neutral float-right" title="Low* buffer libraries" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="TocLibraries.html" class="btn btn-neutral float-left" title="Low* libraries" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2018, Jonathan Protzenko

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>